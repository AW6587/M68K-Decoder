00001500 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/18/2019 2:28:21 AM

00000000                             1  *--------------------------------------------------------------------------
00000000                             2  * Title      : 68K Disassembler 
00000000                             3  * Written by : Midori Williams and Derek Wong-Yee
00000000                             4  * Date       : 3/1/19
00000000                             5  * 
00000000                             6  * Description: 
00000000                             7  * This is the starting file for a 68K instruction dissasembler which reads a starting and
00000000                             8  * ending address from Config.cfg and prints the dissasembled code to Output.txt
00000000                             9  * Responsibilities of Main.X68 are as follows:
00000000                            10  *   -Loads included files into memory: Opcode.X68 and EA.X68
00000000                            11  *   -Establishes/manages start and end address to dissasemble 
00000000                            12  *   -Handles all I/O and global variables/constants/buffers
00000000                            13  *   -Provides methods for hex-ascii conversions, adding to the print buffer, and printing to Output.txt
00000000                            14  
00000000                            15  *---------------------------------------------------------------------------
00001500                            16      ORG    $1500    *location where included files are put
00001500                            17  *---------------------------------------------------------------------------
00001500                            18  START:      
00001500                            19  
00001500  6000 FAFE                 20              BRA     DISASSEMBLER    *jump to actual start of program at ORG $1000
00001504                            21              INCLUDE 'Midori_Williams_Opcode.X68'
00001504                            22  
00001504                            23  
00001504                            24  
00001504                            25  
00001504                            26  
00001504                            27  
00001504                            28  OPCODE:     
00001504  4284                      29              CLR.L   D4      ;clear D4 & D6 just to be safe
00001506  4286                      30              CLR.L   D6      
00001508  284B                      31              MOVE.L  A3, A4      *make a backup copy of the address before postincrementing pointer in A3     
0000150A  361B                      32              MOVE.W  (A3)+, D3    ;D3 is now my opcode word (16B)
0000150C  3803                      33              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
0000150E  103C 000C                 34              MOVE.B  #12, D0     ;shift count for D4
00001512  E0AC                      35              LSR.L   D0, D4      ;shift leading hex code (bits 15-12) to the far right to isolate for decoding
00001514  C8BC 0000000F             36              AND.L   #$F, D4      ;mask uneeded bits/set to zeros
0000151A                            37              
0000151A  0C04 0000                 38              CMPI.B  #$00, D4
0000151E  6700 0058                 39              BEQ     OP0
00001522  0C04 0003                 40              CMPI.B  #$03, D4
00001526  6F00 009A                 41              BLE     OP1            
0000152A  0C04 0004                 42              CMPI.B  #$04, D4
0000152E  6700 00AE                 43              BEQ     OP4            
00001532  0C04 0005                 44              CMPI.B  #$05, D4
00001536  6700 011E                 45              BEQ     OP5            
0000153A  0C04 0006                 46              CMPI.B  #$06, D4
0000153E  6700 0130                 47              BEQ     OP6            
00001542  0C04 0008                 48              CMPI.B  #$08, D4
00001546  6700 0144                 49              BEQ     OP8            
0000154A  0C04 0009                 50              CMPI.B  #$09, D4
0000154E  6700 0FA8                 51              BEQ     decSUB            
00001552  0C04 000B                 52              CMPI.B  #$0B, D4
00001556  6700 0150                 53              BEQ     OPB            
0000155A  0C04 000C                 54              CMPI.B  #$0C, D4
0000155E  6700 104C                 55              BEQ     decMULS            
00001562  0C04 000D                 56              CMPI.B  #$0D, D4
00001566  6700 015C                 57              BEQ     OPD            
0000156A  0C04 000E                 58              CMPI.B  #$0E, D4
0000156E  6700 0170                 59              BEQ     OPE
00001572                            60              
00001572  4EF9 00002BB6             61              JMP     BADFLAG  ;none of the above, can't decode
00001578                            62  
00001578                            63  
00001578                            64  
00001578                            65  
00001578                            66  OP0:
00001578  3803                      67              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
0000157A  103C 0008                 68              MOVE.B  #8, D0      ;shift count for D4
0000157E  E0AC                      69              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding
00001580  C8BC 00000001             70              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001586                            71              
00001586  B83C 0001                 72              CMP.B   #1, D4      ;is it BCLR with data reg as the source?
0000158A  6700 0210                 73              BEQ     decBCLRdr
0000158E                            74     
0000158E                            75              *Nope, not BCLRdr, moveing along...
0000158E  3803                      76              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00001590  103C 0009                 77              MOVE.B  #9, D0      ;shift count for D4
00001594  E0AC                      78              LSR.L   D0, D4      ;shift bits 11-9 to the far right to isolate for decoding
00001596  C8BC 00000007             79              AND.L   #7, D4      ;mask uneeded bits/set to zeros
0000159C                            80              
0000159C  B83C 0000                 81              CMP.B   #0, D4      ;is it ORI? 
000015A0  6700 01AC                 82              BEQ     decORI   
000015A4                            83              
000015A4  B83C 0003                 84              CMP.B   #3, D4      ;is it ADDI? 
000015A8  6700 01BE                 85              BEQ     decADDI   
000015AC                            86              
000015AC  B83C 0004                 87              CMP.B   #4, D4      ;is it BCLR with immediate as the source?
000015B0  6700 0226                 88              BEQ     decBCLRim   
000015B4                            89              
000015B4  B83C 0006                 90              CMP.B   #6, D4      ;is it CMPI?
000015B8  6700 01C8                 91              BEQ     decCMPI     
000015BC                            92              
000015BC  4EF9 00002BB6             93              JMP     BADFLAG     ;else can't be decoded
000015C2                            94  
000015C2                            95   
000015C2                            96  OP1:        
000015C2  3803                      97              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000015C4  103C 0006                 98              MOVE.B  #6, D0      ;shift count for D4
000015C8  E0AC                      99              LSR.L   D0, D4      ;shift bits 8-6 to the far right to isolate for decoding Mode
000015CA  C8BC 00000007            100              AND.L   #7, D4      ;mask uneeded bits/set to zeros
000015D0                           101  
000015D0  B83C 0001                102              CMP.B   #1, D4      ;is it MOVEA?
000015D4  6700 0274                103              BEQ     decMOVEA    ;if yes, decode MOVEA
000015D8  4EF9 000018CE            104              JMP     decMOVE     ;must be MOVE then, decode that instead  
000015DE                           105  
000015DE                           106  OP4:
000015DE  3803                     107              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000015E0  B87C 4E75                108              CMP.W   #$4E75, D4  ;is it RTS?
000015E4  6700 03D2                109              BEQ     decRTS
000015E8                           110              
000015E8                           111              *Nope, not RTS, moveing along....
000015E8  103C 0008                112              MOVE.B  #8, D0      ;shift count for D4
000015EC  E0AC                     113              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding
000015EE  C8BC 00000001            114              AND.L   #1, D4      ;mask uneeded bits/set to zeros
000015F4                           115              
000015F4  B83C 0001                116              CMP.B   #1, D4      ;is it LEA or CHK? 
000015F8  6700 0038                117              BEQ     OP4_1   
000015FC                           118              
000015FC                           119              *Nope, not LEA or CHK, moveing along....
000015FC  3803                     120              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000015FE  103C 0009                121              MOVE.B  #9, D0      ;shift count for D4
00001602  E0AC                     122              LSR.L   D0, D4      ;shift bits 11-9 to the far right to isolate for decoding
00001604  C8BC 00000007            123              AND.L   #7, D4      ;mask uneeded bits/set to zeros
0000160A                           124  
0000160A  B83C 0001                125              CMP.B   #1, D4      ;is it CLR?
0000160E  6700 0374                126              BEQ     decCLR
00001612                           127              
00001612  B83C 0002                128              CMP.B   #2, D4      ;is it NEG?
00001616  6700 0386                129              BEQ     decNEG
0000161A                           130  
0000161A  B83C 0007                131              CMP.B   #7, D4      ;is it JSR?   
0000161E  6700 03A6                132              BEQ     decJSR
00001622                           133              
00001622  B83C 0004                134              CMP.B   #4, D4      ;is it MOVEM register to memory?
00001626  6700 03D4                135              BEQ     decMOVEMr2m
0000162A                           136              
0000162A  B83C 0006                137              CMP.B   #6, D4      ;is it MOVEM memory to register?
0000162E  6700 0452                138              BEQ     decMOVEMm2r
00001632                           139              
00001632                           140  OP4_1:
00001632  3803                     141              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00001634  103C 0006                142              MOVE.B  #6, D0      ;shift count for D4
00001638  E0AC                     143              LSR.L   D0, D4      ;shift bit 6 to the far right to isolate for decoding
0000163A  C8BC 00000001            144              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001640                           145  
00001640  B83C 0001                146              CMP.B   #1, D4      ;is it LEA?
00001644  6700 0A74                147              BEQ     decLEA
00001648                           148              
00001648  B87C 0000                149              CMP     #0, D4      ;is it CHK?
0000164C  6700 0A9E                150              BEQ     decCHK     
00001650                           151              
00001650  4EF9 00002BB6            152              JMP     BADFLAG     ;can't be decoded  
00001656                           153  
00001656                           154  
00001656                           155  
00001656                           156  
00001656                           157  OP5:
00001656  3803                     158              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00001658  103C 0008                159              MOVE.B  #8, D0      ;shift count for D4
0000165C  E0AC                     160              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding
0000165E  C8BC 00000001            161              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001664                           162              
00001664  B83C 0000                163              CMP.B   #0, D4      ;is it ADDQ?
00001668  6700 0B5E                164              BEQ     decADDQ
0000166C  6000 0AEE                165              BRA     decSUBQ     ;else, it's SUBQ
00001670                           166  
00001670                           167  
00001670                           168  
00001670                           169  OP6:
00001670  3803                     170              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00001672  103C 0008                171              MOVE.B  #8, D0      ;shift count for D4
00001676  E0AC                     172              LSR.L   D0, D4      ;shift bits 11-8 to the far right to isolate for decoding condition code
00001678  C8BC 0000000F            173              AND.L   #$F, D4      ;mask uneeded bits/set to zeros
0000167E                           174              
0000167E  B83C 0001                175              CMP.B   #1, D4      ;make sure 4 bits are 0 or between 2-15 range for Bcc conditions
00001682  6600 0BAE                176              BNE     BCC_DECODE  ;if yes, start decoding which branch instruction it is! 
00001686  4EF9 00002BB6            177              JMP     BADFLAG     ;if not, can't decode
0000168C                           178              
0000168C                           179              
0000168C                           180  
0000168C                           181  OP8:
0000168C  3803                     182              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
0000168E  103C 0006                183              MOVE.B  #6, D0      ;shift count for D4
00001692  E0AC                     184              LSR.L   D0, D4      ;shift bits 7-6 to the far right to isolate for decoding            
00001694  C8BC 00000003            185              AND.L   #$3, D4      ;mask uneeded bits/set to zeros
0000169A                           186  
0000169A  B83C 0003                187              CMP.B   #3, D4      ;is it DIVS?
0000169E  6700 0D72                188              BEQ     decDIVS     ;if yes, jump to decoding 
000016A2  4EF9 0000245A            189              JMP     decOR       ;else it's OR, jumpt to decode that
000016A8                           190  
000016A8                           191  
000016A8                           192  
000016A8                           193  
000016A8                           194                                      
000016A8                           195  OPB:
000016A8  3803                     196              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000016AA  103C 0008                197              MOVE.B  #8, D0      ;shift count for D4
000016AE  E0AC                     198              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding            
000016B0  C8BC 00000001            199              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
000016B6                           200  
000016B6  B83C 0001                201              CMP.B   #1, D4      ;is it EOR?
000016BA  6700 0E98                202              BEQ     decEOR     ;if yes, jump to decoding 
000016BE  4EF9 00002580            203              JMP     decCMP      ;else it's CMP, jumpt to decode that
000016C4                           204  
000016C4                           205  
000016C4                           206  
000016C4                           207              
000016C4                           208  
000016C4                           209  OPD:        
000016C4  3803                     210              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000016C6  103C 0006                211              MOVE.B  #6, D0      ;shift count for D4
000016CA  E0AC                     212              LSR.L   D0, D4      ;shift bits 7-6 to the far right to isolate for decoding            
000016CC  C8BC 00000003            213              AND.L   #$3, D4      ;mask uneeded bits/set to zeros
000016D2                           214  
000016D2  B83C 0003                215              CMP.B   #3, D4      ;is it ADDA?
000016D6  6700 0F7C                216              BEQ     decADDA     ;if yes, jump to decoding 
000016DA  4EF9 000025F8            217              JMP     decADD     ;else jump to ADD to decode that
000016E0                           218  
000016E0                           219              
000016E0                           220  
000016E0                           221  OPE:    
000016E0  3803                     222              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000016E2  103C 0006                223              MOVE.B  #6, D0      ;shift count for D4
000016E6  E0AC                     224              LSR.L   D0, D4      ;shift bits 7-6 to the far right to isolate for decoding operation type (dirrect or memory)
000016E8  C8BC 00000003            225              AND.L   #$3, D4      ;mask uneeded bits/set to zeros
000016EE                           226  
000016EE  B83C 0003                227              CMP.B   #3, D4      ;is it a memory operation?
000016F2  6600 002E                228              BNE     OPE_skip    ;if no, jump to next decoding refinement 
000016F6                           229              
000016F6  3803                     230              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000016F8  103C 0009                231              MOVE.B  #9, D0      ;shift count for D4
000016FC  E0AC                     232              LSR.L   D0, D4      ;shift bits 11-9 to the far right to isolate for decoding            
000016FE  C8BC 00000007            233              AND.L   #$7, D4      ;mask uneeded bits/set to zeros
00001704                           234              
00001704  B83C 0000                235              CMP.B   #0, D4     ;is it ASL/ASR?
00001708  6700 0FC0                236              BEQ     decASL
0000170C  B83C 0001                237              CMP.B   #1, D4     ;is it LSL/LSR?
00001710  6700 115C                238              BEQ     decLSL
00001714  B83C 0003                239              CMP.B   #3, D4     ;is it ROL/ROR?
00001718  6700 12F8                240              BEQ     decROL
0000171C                           241  
0000171C  4EF9 00002BB6            242              JMP     BADFLAG     ;if not those, can't decode
00001722                           243  
00001722                           244  OPE_skip    *must be a dirrect operation
00001722  3803                     245              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00001724  103C 0003                246              MOVE.B  #3, D0      ;shift count for D4
00001728  E0AC                     247              LSR.L   D0, D4      ;shift bits 5-3 to the far right to isolate for decoding            
0000172A  C8BC 00000003            248              AND.L   #$3, D4      ;mask uneeded bits/set to zeros
00001730                           249  
00001730  B83C 0000                250              CMP.B   #0, D4     ;is it ASL/ASR using register?
00001734  6700 0FEA                251              BEQ     decASLreg
00001738  B83C 0001                252              CMP.B   #1, D4     ;is it LSL/LSR using register?
0000173C  6700 1186                253              BEQ     decLSLreg
00001740  B83C 0003                254              CMP.B   #3, D4     ;is it ROL/ROR using register?
00001744  6700 1322                255              BEQ     decROLreg
00001748                           256  
00001748  4EF9 00002BB6            257              JMP     BADFLAG     ;if not those, can't decode
0000174E                           258  
0000174E                           259  
0000174E                           260  
0000174E                           261  
0000174E                           262  
0000174E                           263  
0000174E                           264  decORI: 
0000174E  41F9 000012FD            265              LEA     oriMSG, A0     ;load message "ORI"
00001754  4EB9 00001102            266              JSR     ADD2BUFFER     ;add message to printBuffer
0000175A  4EB9 00002E38            267              JSR     GET_IM_SIZE    ;find the size in bits 7-6 (.b, .w, or .l) and append to printBuffer
00001760  4EB9 00002F4E            268              JSR     EA          ;jump to EA code for decoding destination EA and appending to printBuffer
00001766  4E75                     269              RTS                 ;return to Main.X68 
00001768                           270  
00001768                           271            
00001768                           272  
00001768                           273  decADDI: 
00001768  41F9 00001303            274              LEA     addiMSG, A0     ;load message "ADDI"
0000176E  4EB9 00001102            275              JSR     ADD2BUFFER     ;add message to printBuffer
00001774  4EB9 00002E38            276              JSR     GET_IM_SIZE    ;find the size in bits 7-6 (.b, .w, or .l) and append to printBuffer
0000177A  4EB9 00002F4E            277              JSR     EA          ;jump to EA code for decoding destination EA and appending to printBuffer
00001780  4E75                     278              RTS                 ;return to Main.X68 
00001782                           279  
00001782                           280            
00001782                           281  
00001782                           282  
00001782                           283  decCMPI:    
00001782  41F9 0000130A            284              LEA     cmpiMSG, A0     ;load message "CMPI"
00001788  4EB9 00001102            285              JSR     ADD2BUFFER     ;add message to printBuffer
0000178E  4EB9 00002E38            286              JSR     GET_IM_SIZE    ;find the size in bits 7-6 (.b, .w, or .l) and append to printBuffer            
00001794  4EB9 00002F4E            287              JSR     EA      ;jump to EA code for decoding destination EA and appending to printBuffer
0000179A  4E75                     288              RTS             ;return to Main.X68 
0000179C                           289  
0000179C                           290                        
0000179C                           291             
0000179C                           292  decBCLRdr:
0000179C  3803                     293              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
0000179E  103C 0006                294              MOVE.B  #6, D0      ;shift count for D4
000017A2  E0AC                     295              LSR.L   D0, D4      ;shift bits 7-6 to the far right to isolate for decoding
000017A4  C8BC 00000003            296              AND.L   #3, D4      ;mask uneeded bits/set to zeros
000017AA  B83C 0002                297              CMP.B   #%10, D4    ;compare last needed bits to varify it's actually this opcode
000017AE  6600 1406                298              BNE     BADFLAG     ;if != can't decode
000017B2                           299              
000017B2                           300              *Now we know it's BCLR with data reg as source, start decoding
000017B2  41F9 00001311            301              LEA     bclrMSG, A0     ;load message "BCLR"
000017B8  4EB9 00001102            302              JSR     ADD2BUFFER      ;add message to printBuffer
000017BE  4EB9 00002BBC            303              JSR     DECODE_DN   ;decode and load message for the source data register, append to printBuffer
000017C4  41F9 000012E9            304              LEA     comma, A0   ;load message ", "
000017CA  4EB9 00001102            305              JSR     ADD2BUFFER  ;append to printBuffer
000017D0                           306              
000017D0  4EB9 00002F4E            307              JSR     EA      ;jump to EA.X68 to decode destination EA and append to printBuffer
000017D6  4E75                     308              RTS             ;return to Main.X68 
000017D8                           309  
000017D8                           310  
000017D8                           311          
000017D8                           312  decBCLRim:
000017D8  3803                     313              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000017DA  103C 0006                314              MOVE.B  #6, D0      ;shift count for D4
000017DE  E0AC                     315              LSR.L   D0, D4      ;shift bits 7-6 to the far right to isolate for decoding
000017E0  C8BC 00000003            316              AND.L   #3, D4      ;mask uneeded bits/set to zeros
000017E6  B83C 0002                317              CMP.B   #%10, D4    ;compare last needed bits to varify it's actually this opcode
000017EA  6600 13CA                318              BNE     BADFLAG     ;if != can't decode
000017EE                           319              
000017EE                           320              *Now we know it's BCLR with immediate as source, load buffers and start decoding
000017EE  41F9 00001311            321              LEA     bclrMSG, A0     ;load message "BCLR"
000017F4  4EB9 00001102            322              JSR     ADD2BUFFER      ;append message to printBuffer
000017FA  41F9 000012EC            323              LEA     hashtag, A0     ;load "#"
00001800  4EB9 00001102            324              JSR     ADD2BUFFER      ;append message to printBuffer
00001806  41F9 000012EE            325              LEA     hexSign, A0     ;load "$"
0000180C  4EB9 00001102            326              JSR     ADD2BUFFER
00001812                           327              
00001812  4284                     328              CLR.L   D4              ;clear register  
00001814  4280                     329              CLR.L   D0              ;clear register
00001816  3E03                     330              MOVE.W  D3, D7          ;backup current opcode word before reading next 2 bytes
00001818  384B                     331              MOVE.W  A3, A4          ;update address pointer incase opcode still can't be decoded at some point
0000181A  361B                     332              MOVE.W  (A3)+, D3       ;grab the immediate data from the word after the opcode
0000181C  3803                     333              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
0000181E  103C 0008                334              MOVE.B  #8,D0           ;load length of hex value
00001822  4EB9 0000110C            335              JSR     HexToAscii      ;convert to ascii, puts in hex2ascBuffer
00001828  41F9 000012DE            336              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
0000182E  4EB9 00001102            337              JSR     ADD2BUFFER      ;append immediate value to buffer
00001834                           338             
00001834  41F9 000012E9            339              LEA     comma, A0   ;load message ", "
0000183A  4EB9 00001102            340              JSR     ADD2BUFFER  ;append to printBuffer
00001840                           341              
00001840  3607                     342              MOVE.W  D7, D3   ;restore opcode for EA to read 
00001842  4EB9 00002F4E            343              JSR     EA      ;jump to EA.X68 to decode destination EA and append to printBuffer
00001848  4E75                     344              RTS             ;return to Main.X68 
0000184A                           345  
0000184A                           346  
0000184A                           347  decMOVEA:   
0000184A  41F9 00001319            348              LEA     moveaMSG, A0     ;load message "MOVEA"
00001850  4EB9 00001102            349              JSR     ADD2BUFFER     ;add message to printBuffer
00001856                           350              
00001856  3803                     351              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00001858  103C 000C                352              MOVE.B  #12, D0      ;shift count for D4
0000185C  E0AC                     353              LSR.L   D0, D4      ;shift bits 13-12 to the far right to isolate for decoding size (.b, .w, .l)
0000185E  C8BC 00000003            354              AND.L   #3, D4      ;mask uneeded bits/set to zeros
00001864                           355  
00001864  B83C 0003                356              CMP.B   #3, D4  ;is it .W?
00001868  6600 002C                357              BNE     ma_skip1 ;skip if not
0000186C                           358              
0000186C  41F9 00001427            359              LEA     wordMSG, A0   ;if yes, load ".W "
00001872  4EB9 00001102            360              JSR     ADD2BUFFER    ;add message to printBuffer
00001878  1C3C 0010                361              MOVE.B  #16, D6       ;set size for EA to decode immediate data
0000187C  4EB9 00002F4E            362              JSR     EA          ;decode source from EA.X68, load to printBuffer
00001882  41F9 000012E9            363              LEA     comma, A0   ;add a comma ", "
00001888  4EB9 00001102            364              JSR     ADD2BUFFER  ;add it to printBuffer
0000188E  4EB9 00002F62            365              JSR     MOVE_EA     ;decode destination Address register in EA.X68, load to printBuffer
00001894  4E75                     366              RTS             ;return to Main.X68
00001896                           367  ma_skip1
00001896  B83C 0002                368              CMP.B   #2, D4  ;is it .L?
0000189A  6600 002C                369              BNE     ma_skip2 ;skip if not
0000189E                           370              
0000189E  41F9 0000142B            371              LEA     longMSG, A0   ;if yes, load ".L "
000018A4  4EB9 00001102            372              JSR     ADD2BUFFER    ;add message to printBuffer
000018AA  1C3C 0020                373              MOVE.B  #32, D6       ;set size for EA to decode immediate data
000018AE  4EB9 00002F4E            374              JSR     EA          ;decode source from EA.X68, load to printBuffer
000018B4  41F9 000012E9            375              LEA     comma, A0   ;add a comma ", "
000018BA  4EB9 00001102            376              JSR     ADD2BUFFER  ;add it to printBuffer
000018C0  4EB9 00002F62            377              JSR     MOVE_EA     ;decode destination address register in EA.X68, load to printBuffer
000018C6  4E75                     378              RTS
000018C8                           379  ma_skip2    
000018C8  4EB9 00002BB6            380              JSR     BADFLAG     ;invalid size, can't decode            
000018CE                           381              
000018CE                           382  
000018CE                           383  decMOVE:
000018CE  41F9 00001321            384              LEA     moveMSG, A0     ;load message "MOVEA"
000018D4  4EB9 00001102            385              JSR     ADD2BUFFER     ;add message to printBuffer
000018DA                           386              
000018DA  3803                     387              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000018DC  103C 000C                388              MOVE.B  #12, D0      ;shift count for D4
000018E0  E0AC                     389              LSR.L   D0, D4      ;shift bits 13-12 to the far right to isolate for decoding size (.b, .w, .l)
000018E2  C8BC 00000003            390              AND.L   #3, D4      ;mask uneeded bits/set to zeros
000018E8                           391              
000018E8  B83C 0001                392              CMP.B   #1, D4  ;is it .B?
000018EC  6600 002C                393              BNE     m_skip1 ;skip if not
000018F0                           394              
000018F0  41F9 00001427            395              LEA     wordMSG, A0   ;if yes, load ".B "
000018F6  4EB9 00001102            396              JSR     ADD2BUFFER    ;add message to printBuffer
000018FC  1C3C 0008                397              MOVE.B  #8, D6       ;set size for EA to decode immediate data
00001900  4EB9 00002F4E            398              JSR     EA          ;decode source from EA.X68, load to printBuffer
00001906  41F9 000012E9            399              LEA     comma, A0   ;add a comma ", "
0000190C  4EB9 00001102            400              JSR     ADD2BUFFER  ;add it to printBuffer
00001912  4EB9 00002F62            401              JSR     MOVE_EA     ;decode destination Address register in EA.X68, load to printBuffer
00001918  4E75                     402              RTS             ;return to Main.X68 
0000191A                           403              
0000191A                           404  m_skip1     
0000191A  B83C 0003                405              CMP.B   #3, D4  ;is it .W?
0000191E  6600 002C                406              BNE     m_skip2 ;skip if not 
00001922                           407        
00001922  41F9 00001427            408              LEA     wordMSG, A0   ;if yes, load ".W "
00001928  4EB9 00001102            409              JSR     ADD2BUFFER    ;add message to printBuffer
0000192E  1C3C 0010                410              MOVE.B  #16, D6       ;set size for EA to decode immediate data
00001932  4EB9 00002F4E            411              JSR     EA          ;decode source from EA.X68, load to printBuffer
00001938  41F9 000012E9            412              LEA     comma, A0   ;add a comma ", "
0000193E  4EB9 00001102            413              JSR     ADD2BUFFER  ;add it to printBuffer
00001944  4EB9 00002F62            414              JSR     MOVE_EA     ;decode destination Address register in EA.X68, load to printBuffer
0000194A  4E75                     415              RTS             ;return to Main.X68
0000194C                           416  m_skip2
0000194C  B83C 0002                417              CMP.B   #2, D4  ;is it .L?
00001950  6600 002C                418              BNE     m_skip3 ;skip if not
00001954                           419              
00001954  41F9 0000142B            420              LEA     longMSG, A0   ;if yes, load ".L "
0000195A  4EB9 00001102            421              JSR     ADD2BUFFER    ;add message to printBuffer
00001960  1C3C 0020                422              MOVE.B  #32, D6       ;set size for EA to decode immediate data
00001964  4EB9 00002F4E            423              JSR     EA          ;decode source from EA.X68, load to printBuffer
0000196A  41F9 000012E9            424              LEA     comma, A0   ;add a comma ", "
00001970  4EB9 00001102            425              JSR     ADD2BUFFER  ;add it to printBuffer
00001976  4EB9 00002F62            426              JSR     MOVE_EA     ;decode destination address register in EA.X68, load to printBuffer
0000197C  4E75                     427              RTS
0000197E                           428  m_skip3    
0000197E  4EB9 00002BB6            429              JSR     BADFLAG     ;invalid size, can't decode     
00001984                           430  
00001984                           431  
00001984                           432  
00001984                           433  decCLR:  
00001984  41F9 00001328            434              LEA     clrMSG, A0  ;load "CLR" message
0000198A  4EB9 00001102            435              JSR     ADD2BUFFER  ;add message to buffer
00001990  4EB9 00002DD8            436              JSR     GET_SIZE    ;get size (.b, .w, or .l) and append to printBuffer
00001996  4EB9 00002F4E            437              JSR     EA  ;jump to EA.X68 to decode destination EA and append to printBuffer
0000199C  4E75                     438              RTS         ;return to MAIN.X68 for printing
0000199E                           439  
0000199E                           440  
0000199E                           441  
0000199E                           442  decNEG:  
0000199E  41F9 0000132E            443              LEA     negMSG, A0  ;load "NEG" message
000019A4  4EB9 00001102            444              JSR     ADD2BUFFER  ;add message to buffer
000019AA  4EB9 00002DD8            445              JSR     GET_SIZE    ;get size (.b, .w, or .l) and append to printBuffer
000019B0  4EB9 00002F4E            446              JSR     EA          ;jump to EA.X68 to decode destination EA and append to printBuffer
000019B6  4E75                     447              RTS         ;return to MAIN.X68 for printing
000019B8                           448              
000019B8                           449  
000019B8                           450  
000019B8                           451  decRTS:
000019B8  41F9 00001334            452              LEA     rtsMSG, A0      ;load "RTS" message
000019BE  4EB9 00001102            453              JSR     ADD2BUFFER      ;add message to printBuffer
000019C4  4E75                     454              RTS                 ;return to MAIN.X68 for printing
000019C6                           455        
000019C6                           456  
000019C6                           457        
000019C6                           458  decJSR:
000019C6  3803                     459              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000019C8  103C 0006                460              MOVE.B  #6, D0      ;shift count for D4
000019CC  E0AC                     461              LSR.L   D0, D4      ;shift bits 7-6 to the far right to isolate for decoding Address reg
000019CE  C8BC 00000007            462              AND.L   #7, D4      ;mask uneeded bits/set to zeros
000019D4                           463              
000019D4  B87C 0002                464              CMP     #2, D4      ;last check to make sure it's actually JSR
000019D8  6600 11DC                465              BNE     BADFLAG     ;if not, can't decode
000019DC                           466              
000019DC  41F9 0000133A            467              LEA     jsrMSG, A0     ;load message "jsr"
000019E2  4EB9 00001102            468              JSR     ADD2BUFFER     ;add message to printBuffer
000019E8  41F9 000012F2            469              LEA     space, A0      ;load text spaceing
000019EE  4EB9 00001102            470              JSR     ADD2BUFFER     ;add message to printBuffer
000019F4  4EB9 00002F4E            471              JSR     EA          ;jump to EA.X68 to decode source EA and append to printBuffer
000019FA                           472              
000019FA  4E75                     473              RTS                 ;return to MAIN.X68 for printing
000019FC                           474  
000019FC                           475  decMOVEMr2m: 
000019FC  41F9 00001341            476              LEA     movemMSG, A0     ;load message "MOVEM"
00001A02  4EB9 00001102            477              JSR     ADD2BUFFER     ;add message to printBuffer
00001A08                           478  
00001A08  3803                     479              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00001A0A  103C 0006                480              MOVE.B  #6, D0      ;shift count for D4
00001A0E  E0AC                     481              LSR.L   D0, D4      ;shift bits 7-6 to the far right to isolate for decoding size
00001A10  C8BC 00000003            482              AND.L   #3, D4      ;mask uneeded bits/set to zeros
00001A16                           483  r2m_word            
00001A16  B87C 0002                484              CMP     #2, D4      ;is it .W?
00001A1A  6600 0030                485              BNE     r2m_long    ;if not, try .L
00001A1E                           486              
00001A1E  41F9 00001427            487              LEA     wordMSG, A0     ;load message ".W "
00001A24  4EB9 00001102            488              JSR     ADD2BUFFER     ;add message to printBuffer
00001A2A                           489              
00001A2A  3E03                     490              MOVE.W  D3, D7      ;make opcode copy since reg decode increments pointer
00001A2C  384B                     491              MOVE.W  A3, A4          ;update address pointer incase opcode still can't be decoded at some point
00001A2E  361B                     492              MOVE.W  (A3)+, D3       ;grab register list from the word AFTER opcode, store in D7 so D3 still holds current opcode for EA
00001A30  4EB9 00001B04            493              JSR     movem_decode_regs ;skip over to decoding source register list, appends to printBuffer
00001A36                           494              
00001A36  41F9 000012E9            495              LEA     comma, A0   ;load message ", "
00001A3C  4EB9 00001102            496              JSR     ADD2BUFFER  ;append to printBuffer
00001A42                           497              
00001A42  3607                     498              MOVE.W  D7, D3   ;restore opcode for EA to read
00001A44  4EB9 00002F4E            499              JSR     EA       ;decode EA for the destination, appends to printBuffer
00001A4A  4E75                     500              RTS              ;return to Main.X68
00001A4C                           501              
00001A4C  B87C 0003                502  r2m_long    CMP     #3, D4      ;is it .L?
00001A50  6600 1164                503              BNE     BADFLAG     ;if not, can't decode
00001A54                           504              
00001A54  41F9 0000142B            505              LEA     longMSG, A0     ;load message ".L "
00001A5A  4EB9 00001102            506              JSR     ADD2BUFFER     ;add message to printBuffer
00001A60                           507              
00001A60  3E03                     508              MOVE.W  D3, D7      ;make opcode copy since reg decode increments pointer
00001A62  384B                     509              MOVE.W  A3, A4          ;update address pointer incase opcode still can't be decoded at some point
00001A64  361B                     510              MOVE.W  (A3)+, D3       ;grab register list from the word AFTER opcode, store in D7 so D3 still holds current opcode for EA
00001A66  4EB9 00001B04            511              JSR     movem_decode_regs ;skip over to decoding source register list, appends to printBuffer
00001A6C                           512  
00001A6C  41F9 000012E9            513              LEA     comma, A0   ;load message ", "
00001A72  4EB9 00001102            514              JSR     ADD2BUFFER  ;append to printBuffer
00001A78                           515  
00001A78  3607                     516              MOVE.W  D7, D3   ;restore opcode for EA to read
00001A7A  4EB9 00002F4E            517              JSR     EA       ;decode EA for the destination, appends to printBuffer
00001A80  4E75                     518              RTS              ;return to Main.X68
00001A82                           519  
00001A82                           520  decMOVEMm2r:
00001A82  41F9 00001341            521              LEA     movemMSG, A0     ;load message "MOVEM"
00001A88  4EB9 00001102            522              JSR     ADD2BUFFER     ;add message to printBuffer
00001A8E                           523  
00001A8E  3803                     524              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00001A90  103C 0006                525              MOVE.B  #6, D0      ;shift count for D4
00001A94  E0AC                     526              LSR.L   D0, D4      ;shift bits 7-6 to the far right to isolate for decoding size
00001A96  C8BC 00000003            527              AND.L   #3, D4      ;mask uneeded bits/set to zeros
00001A9C                           528  m2r_word            
00001A9C  B87C 0002                529              CMP     #2, D4      ;is it .W?
00001AA0  6600 002E                530              BNE     m2r_long    ;if not, try .L
00001AA4                           531              
00001AA4  41F9 00001427            532              LEA     wordMSG, A0     ;load message ".W "
00001AAA  4EB9 00001102            533              JSR     ADD2BUFFER     ;add message to printBuffer
00001AB0                           534              
00001AB0  384B                     535              MOVE.W  A3, A4          ;update address pointer incase opcode still can't be decoded at some point
00001AB2  3E1B                     536              MOVE.W  (A3)+, D7       ;grab register list from the word AFTER opcode, store in D7 so D3 still holds current opcode for EA            
00001AB4  4EB9 00002F4E            537              JSR     EA           ;decode EA for the source, appends to printBuffer
00001ABA                           538  
00001ABA  41F9 000012E9            539              LEA     comma, A0   ;load message ", "
00001AC0  4EB9 00001102            540              JSR     ADD2BUFFER  ;append to printBuffer  
00001AC6                           541   
00001AC6  3607                     542              MOVE.W  D7, D3      ;update D3 so it now holds register list         
00001AC8  4EB9 00001DEA            543              JSR     movem_postD0 ;skip over to decoding source register list, appends to printBuffer
00001ACE                           544  
00001ACE  4E75                     545              RTS                 ;return to Main.X68
00001AD0                           546                  
00001AD0  B87C 0003                547  m2r_long    CMP     #3, D4      ;is it .L?
00001AD4  6600 10E0                548              BNE     BADFLAG     ;if not, can't decode
00001AD8                           549              
00001AD8  41F9 0000142B            550              LEA     longMSG, A0     ;load message ".L "
00001ADE  4EB9 00001102            551              JSR     ADD2BUFFER     ;add message to printBuffer
00001AE4                           552              
00001AE4  384B                     553              MOVE.W  A3, A4          ;update address pointer incase opcode still can't be decoded at some point
00001AE6  3E1B                     554              MOVE.W  (A3)+, D7       ;grab register list from the word AFTER opcode, store in D7 so D3 still holds current opcode for EA   
00001AE8  4EB9 00002F4E            555              JSR     EA            ;decode EA for the source, appends to printBuffer
00001AEE                           556              
00001AEE  41F9 000012E9            557              LEA     comma, A0     ;load message ", "
00001AF4  4EB9 00001102            558              JSR     ADD2BUFFER    ;append to printBuffer 
00001AFA                           559  
00001AFA  3607                     560              MOVE.W  D7, D3        ;update D3 so it now holds register list                    
00001AFC  4EB9 00001DEA            561              JSR     movem_postD0 ;skip over to decoding source register list, appends to printBuffer
00001B02                           562  
00001B02  4E75                     563              RTS              ;return to Main.X68
00001B04                           564             
00001B04                           565  movem_decode_regs
00001B04  3807                     566              MOVE.W  D7, D4      ;make a temp copy of opcode in D4 for manipulation
00001B06  103C 0003                567              MOVE.B  #3, D0      ;shift count for D4
00001B0A  E0AC                     568              LSR.L   D0, D4      ;shift bits 5-3 to far right for decoding mode/reg list masking order
00001B0C  C8BC 00000007            569              AND.L   #7, D4      ;mask uneeded bits/set to zeros
00001B12                           570              
00001B12  B83C 0004                571              CMP.B   #4, D4      ;if mode is -(An) predecrement, then bit order is msb - lsb, reg D0-D7/A0-A7
00001B16  6600 02D2                572              BNE     movem_postD0 ;else bit order is postincrement, lsb - msb, reg A7-A0/D7-D0
00001B1A                           573  movem_preD0
00001B1A  3803                     574              MOVE.W  D3, D4      ;make a temp copy of reg list in D4 for manipulation
00001B1C  103C 000F                575              MOVE.B  #15, D0     ;shift count for D4
00001B20  E0AC                     576              LSR.L   D0, D4      ;shift bit 15 to the far right to isolate for decoding D0
00001B22  C8BC 00000001            577              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001B28                           578              
00001B28  B83C 0001                579              CMP.B   #1, D4     ;is bit set?
00001B2C  6600 001A                580              BNE     movem_preD1
00001B30                           581              
00001B30  41F9 0000142F            582              LEA     d0MSG, A0    ;load message "D0"
00001B36  4EB9 00001102            583              JSR     ADD2BUFFER  ;add it to printBuffer
00001B3C  41F9 000012F0            584              LEA     forwardSlash, A0    ;load "/"
00001B42  4EB9 00001102            585              JSR     ADD2BUFFER  ;add it to printBuffer
00001B48                           586              *continue with next bit check
00001B48                           587  movem_preD1
00001B48  3803                     588              MOVE.W  D3, D4      ;make a temp copy of reg list in D4 for manipulation
00001B4A  103C 000E                589              MOVE.B  #14, D0     ;shift count for D4
00001B4E  E0AC                     590              LSR.L   D0, D4      ;shift bit 14 to the far right to isolate for decoding D0
00001B50  C8BC 00000001            591              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001B56                           592              
00001B56  B83C 0001                593              CMP.B   #1, D4     ;is bit set?
00001B5A  6600 001A                594              BNE     movem_preD2
00001B5E                           595              
00001B5E  41F9 00001432            596              LEA     d1MSG, A0    ;load message "D1"
00001B64  4EB9 00001102            597              JSR     ADD2BUFFER  ;add it to printBuffer
00001B6A  41F9 000012F0            598              LEA     forwardSlash, A0    ;load "/"
00001B70  4EB9 00001102            599              JSR     ADD2BUFFER  ;add it to printBuffer
00001B76                           600              *continue with next bit check
00001B76                           601  movem_preD2
00001B76  3803                     602              MOVE.W  D3, D4      ;make a temp copy of reg list in D4 for manipulation
00001B78  103C 000D                603              MOVE.B  #13, D0     ;shift count for D4
00001B7C  E0AC                     604              LSR.L   D0, D4      ;shift bit 13 to the far right to isolate for decoding D0
00001B7E  C8BC 00000001            605              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001B84                           606              
00001B84  B83C 0001                607              CMP.B   #1, D4     ;is bit set?
00001B88  6600 001A                608              BNE     movem_preD3
00001B8C                           609              
00001B8C  41F9 00001435            610              LEA     d2MSG, A0    ;load message "D2"
00001B92  4EB9 00001102            611              JSR     ADD2BUFFER  ;add it to printBuffer
00001B98  41F9 000012F0            612              LEA     forwardSlash, A0    ;load "/"
00001B9E  4EB9 00001102            613              JSR     ADD2BUFFER  ;add it to printBuffer
00001BA4                           614              *continue with next bit check
00001BA4                           615  movem_preD3 
00001BA4  3803                     616              MOVE.W  D3, D4      ;make a temp copy of reg list in D4 for manipulation
00001BA6  103C 000C                617              MOVE.B  #12, D0     ;shift count for D4
00001BAA  E0AC                     618              LSR.L   D0, D4      ;shift bit 12 to the far right to isolate for decoding D3
00001BAC  C8BC 00000001            619              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001BB2                           620              
00001BB2  B83C 0001                621              CMP.B   #1, D4     ;is bit set?
00001BB6  6600 001A                622              BNE     movem_preD4
00001BBA                           623              
00001BBA  41F9 00001438            624              LEA     d3MSG, A0    ;load message "D3"
00001BC0  4EB9 00001102            625              JSR     ADD2BUFFER  ;add it to printBuffer
00001BC6  41F9 000012F0            626              LEA     forwardSlash, A0    ;load "/"
00001BCC  4EB9 00001102            627              JSR     ADD2BUFFER  ;add it to printBuffer
00001BD2                           628              *continue with next bit check      
00001BD2                           629  movem_preD4
00001BD2  3803                     630              MOVE.W  D3, D4      ;make a temp copy of reg list in D4 for manipulation
00001BD4  103C 000B                631              MOVE.B  #11, D0     ;shift count for D4
00001BD8  E0AC                     632              LSR.L   D0, D4      ;shift bit 11 to the far right to isolate for decoding D4
00001BDA  C8BC 00000001            633              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001BE0                           634              
00001BE0  B83C 0001                635              CMP.B   #1, D4     ;is bit set?
00001BE4  6600 001A                636              BNE     movem_preD5
00001BE8                           637              
00001BE8  41F9 0000143B            638              LEA     d4MSG, A0    ;load message "D4"
00001BEE  4EB9 00001102            639              JSR     ADD2BUFFER  ;add it to printBuffer
00001BF4  41F9 000012F0            640              LEA     forwardSlash, A0    ;load "/"
00001BFA  4EB9 00001102            641              JSR     ADD2BUFFER  ;add it to printBuffer
00001C00                           642              *continue with next bit check
00001C00                           643  movem_preD5
00001C00  3803                     644              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001C02  103C 000A                645              MOVE.B  #10, D0     ;shift count for D4
00001C06  E0AC                     646              LSR.L   D0, D4      ;shift bit 10 to the far right to isolate for decoding D5
00001C08  C8BC 00000001            647              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001C0E                           648              
00001C0E  B83C 0001                649              CMP.B   #1, D4     ;is bit set?
00001C12  6600 001A                650              BNE     movem_preD6
00001C16                           651              
00001C16  41F9 0000143E            652              LEA     d5MSG, A0    ;load message "D5"
00001C1C  4EB9 00001102            653              JSR     ADD2BUFFER  ;add it to printBuffer
00001C22  41F9 000012F0            654              LEA     forwardSlash, A0    ;load "/"
00001C28  4EB9 00001102            655              JSR     ADD2BUFFER  ;add it to printBuffer
00001C2E                           656              *continue with next bit check
00001C2E                           657  movem_preD6
00001C2E  3803                     658              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001C30  103C 0009                659              MOVE.B  #9, D0      ;shift count for D4
00001C34  E0AC                     660              LSR.L   D0, D4      ;shift bit 9 to the far right to isolate for decoding D6
00001C36  C8BC 00000001            661              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001C3C                           662              
00001C3C  B83C 0001                663              CMP.B   #1, D4     ;is bit set?
00001C40  6600 001A                664              BNE     movem_preD7
00001C44                           665              
00001C44  41F9 00001441            666              LEA     d6MSG, A0    ;load message "D6"
00001C4A  4EB9 00001102            667              JSR     ADD2BUFFER  ;add it to printBuffer
00001C50  41F9 000012F0            668              LEA     forwardSlash, A0   ;load "/"
00001C56  4EB9 00001102            669              JSR     ADD2BUFFER  ;add it to printBuffer
00001C5C                           670              *continue with next bit check
00001C5C                           671  movem_preD7
00001C5C  3803                     672              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001C5E  103C 0008                673              MOVE.B  #8, D0     ;shift count for D4
00001C62  E0AC                     674              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding D7
00001C64  C8BC 00000001            675              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001C6A                           676              
00001C6A  B83C 0001                677              CMP.B   #1, D4     ;is bit set?
00001C6E  6600 001A                678              BNE     movem_preA0
00001C72                           679              
00001C72  41F9 00001444            680              LEA     d7MSG, A0    ;load message "D7"
00001C78  4EB9 00001102            681              JSR     ADD2BUFFER  ;add it to printBuffer
00001C7E  41F9 000012F0            682              LEA     forwardSlash, A0    ;load "/"
00001C84  4EB9 00001102            683              JSR     ADD2BUFFER  ;add it to printBuffer
00001C8A                           684              *continue with next bit check
00001C8A                           685  movem_preA0
00001C8A  3803                     686              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001C8C  103C 0007                687              MOVE.B  #7, D0     ;shift count for A0
00001C90  E0AC                     688              LSR.L   D0, D4      ;shift bit 7 to the far right to isolate for decoding A0
00001C92  C8BC 00000001            689              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001C98                           690              
00001C98  B83C 0001                691              CMP.B   #1, D4     ;is bit set?
00001C9C  6600 001A                692              BNE     movem_preA1
00001CA0                           693              
00001CA0  41F9 00001447            694              LEA     ar0MSG, A0    ;load message "A0"
00001CA6  4EB9 00001102            695              JSR     ADD2BUFFER  ;add it to printBuffer
00001CAC  41F9 000012F0            696              LEA     forwardSlash, A0    ;load "/"
00001CB2  4EB9 00001102            697              JSR     ADD2BUFFER  ;add it to printBuffer
00001CB8                           698              *continue with next bit check
00001CB8                           699  movem_preA1
00001CB8  3803                     700              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001CBA  103C 0006                701              MOVE.B  #6, D0     ;shift count for A1
00001CBE  E0AC                     702              LSR.L   D0, D4      ;shift bit 6 to the far right to isolate for decoding A1
00001CC0  C8BC 00000001            703              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001CC6                           704              
00001CC6  B83C 0001                705              CMP.B   #1, D4     ;is bit set?
00001CCA  6600 001A                706              BNE     movem_preA2
00001CCE                           707              
00001CCE  41F9 0000144A            708              LEA     ar1MSG, A0    ;load message "A1"
00001CD4  4EB9 00001102            709              JSR     ADD2BUFFER  ;add it to printBuffer
00001CDA  41F9 000012F0            710              LEA     forwardSlash, A0    ;load "/"
00001CE0  4EB9 00001102            711              JSR     ADD2BUFFER  ;add it to printBuffer
00001CE6                           712              *continue with next bit check
00001CE6                           713  movem_preA2
00001CE6  3803                     714              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001CE8  103C 0005                715              MOVE.B  #5, D0     ;shift count for A2
00001CEC  E0AC                     716              LSR.L   D0, D4      ;shift bit 5 to the far right to isolate for decoding A2
00001CEE  C8BC 00000001            717              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001CF4                           718              
00001CF4  B83C 0001                719              CMP.B   #1, D4     ;is bit set?
00001CF8  6600 001A                720              BNE     movem_preA3
00001CFC                           721              
00001CFC  41F9 0000144D            722              LEA     ar2MSG, A0    ;load message "A2"
00001D02  4EB9 00001102            723              JSR     ADD2BUFFER  ;add it to printBuffer
00001D08  41F9 000012F0            724              LEA     forwardSlash, A0    ;load "/"
00001D0E  4EB9 00001102            725              JSR     ADD2BUFFER  ;add it to printBuffer
00001D14                           726              *continue with next bit check
00001D14                           727  movem_preA3
00001D14  3803                     728              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001D16  103C 0004                729              MOVE.B  #4, D0     ;shift count for A3
00001D1A  E0AC                     730              LSR.L   D0, D4      ;shift bit 4 to the far right to isolate for decoding A3
00001D1C  C8BC 00000001            731              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001D22                           732              
00001D22  B83C 0001                733              CMP.B   #1, D4     ;is bit set?
00001D26  6600 001A                734              BNE     movem_preA4
00001D2A                           735              
00001D2A  41F9 00001450            736              LEA     ar3MSG, A0    ;load message "A3"
00001D30  4EB9 00001102            737              JSR     ADD2BUFFER  ;add it to printBuffer
00001D36  41F9 000012F0            738              LEA     forwardSlash, A0    ;load "/"
00001D3C  4EB9 00001102            739              JSR     ADD2BUFFER  ;add it to printBuffer
00001D42                           740              *continue with next bit check
00001D42                           741  movem_preA4
00001D42  3803                     742              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001D44  103C 0007                743              MOVE.B  #7, D0     ;shift count for A4
00001D48  E0AC                     744              LSR.L   D0, D4      ;shift bit 3 to the far right to isolate for decoding A4
00001D4A  C8BC 00000001            745              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001D50                           746              
00001D50  B83C 0001                747              CMP.B   #1, D4     ;is bit set?
00001D54  6600 001A                748              BNE     movem_preA5
00001D58                           749              
00001D58  41F9 00001453            750              LEA     ar4MSG, A0    ;load message "A4"
00001D5E  4EB9 00001102            751              JSR     ADD2BUFFER  ;add it to printBuffer
00001D64  41F9 000012F0            752              LEA     forwardSlash, A0    ;load "/"
00001D6A  4EB9 00001102            753              JSR     ADD2BUFFER  ;add it to printBuffer
00001D70                           754              *continue with next bit check
00001D70                           755  movem_preA5
00001D70  3803                     756              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001D72  103C 0002                757              MOVE.B  #2, D0     ;shift count for A5
00001D76  E0AC                     758              LSR.L   D0, D4      ;shift bit 2 to the far right to isolate for decoding A5
00001D78  C8BC 00000001            759              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001D7E                           760              
00001D7E  B83C 0001                761              CMP.B   #1, D4     ;is bit set?
00001D82  6600 001A                762              BNE     movem_preA6
00001D86                           763              
00001D86  41F9 00001456            764              LEA     ar5MSG, A0    ;load message "A5"
00001D8C  4EB9 00001102            765              JSR     ADD2BUFFER  ;add it to printBuffer
00001D92  41F9 000012F0            766              LEA     forwardSlash, A0    ;load "/"
00001D98  4EB9 00001102            767              JSR     ADD2BUFFER  ;add it to printBuffer
00001D9E                           768              *continue with next bit check
00001D9E                           769  movem_preA6
00001D9E  3803                     770              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001DA0  103C 0001                771              MOVE.B  #1, D0     ;shift count for A6
00001DA4  E0AC                     772              LSR.L   D0, D4      ;shift bit 1 to the far right to isolate for decoding A6
00001DA6  C8BC 00000001            773              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001DAC                           774              
00001DAC  B83C 0001                775              CMP.B   #1, D4     ;is bit set?
00001DB0  6600 001A                776              BNE     movem_preA7
00001DB4                           777              
00001DB4  41F9 00001459            778              LEA     ar6MSG, A0    ;load message "A6"
00001DBA  4EB9 00001102            779              JSR     ADD2BUFFER  ;add it to printBuffer
00001DC0  41F9 000012F0            780              LEA     forwardSlash, A0    ;load "/"
00001DC6  4EB9 00001102            781              JSR     ADD2BUFFER  ;add it to printBuffer
00001DCC                           782              *continue with next bit check
00001DCC                           783  movem_preA7
00001DCC  3803                     784              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001DCE  C8BC 00000001            785              AND.L   #1, D4      ;mask uneeded bits/set to zeros to decode A7
00001DD4                           786              
00001DD4  B83C 0001                787              CMP.B   #1, D4     ;is bit set?
00001DD8  6600 000E                788              BNE     movem_preEnd
00001DDC                           789              
00001DDC  41F9 0000145C            790              LEA     ar7MSG, A0    ;load message "A7"
00001DE2  4EB9 00001102            791              JSR     ADD2BUFFER  ;add it to printBuffer
00001DE8                           792              
00001DE8                           793  movem_preEnd             
00001DE8  4E75                     794              RTS        ;return to movem caller
00001DEA                           795  
00001DEA                           796  
00001DEA                           797  
00001DEA                           798  movem_postD0
00001DEA  3803                     799              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001DEC  C8BC 00000001            800              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001DF2                           801              
00001DF2  B83C 0001                802              CMP.B   #1, D4      ;is bit set?
00001DF6  6600 001A                803              BNE     movem_postD1
00001DFA                           804              
00001DFA  41F9 0000142F            805              LEA     d0MSG, A0    ;load message "D0"
00001E00  4EB9 00001102            806              JSR     ADD2BUFFER   ;add it to printBuffer
00001E06  41F9 000012F0            807              LEA     forwardSlash, A0    ;load "/"
00001E0C  4EB9 00001102            808              JSR     ADD2BUFFER  ;add it to printBuffer
00001E12                           809              *continue with next bit check 
00001E12                           810  movem_postD1
00001E12  3803                     811              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001E14  103C 0001                812              MOVE.B  #1, D0      ;shift count for D4
00001E18  E0AC                     813              LSR.L   D0, D4      ;shift bit 14 to the far right to isolate for decoding D0
00001E1A  C8BC 00000001            814              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001E20                           815              
00001E20  B83C 0001                816              CMP.B   #1, D4      ;is bit set?
00001E24  6600 001A                817              BNE     movem_postD2
00001E28                           818              
00001E28  41F9 00001432            819              LEA     d1MSG, A0    ;load message "D1"
00001E2E  4EB9 00001102            820              JSR     ADD2BUFFER  ;add it to printBuffer
00001E34  41F9 000012F0            821              LEA     forwardSlash, A0    ;load "/"
00001E3A  4EB9 00001102            822              JSR     ADD2BUFFER  ;add it to printBuffer
00001E40                           823              *continue with next bit check 
00001E40                           824  movem_postD2
00001E40  3803                     825              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001E42  103C 0002                826              MOVE.B  #2, D0     ;shift count for D4
00001E46  E0AC                     827              LSR.L   D0, D4      ;shift bit 13 to the far right to isolate for decoding D0
00001E48  C8BC 00000001            828              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001E4E                           829              
00001E4E  B83C 0001                830              CMP.B   #1, D4     ;is bit set?
00001E52  6600 001A                831              BNE     movem_postD3
00001E56                           832              
00001E56  41F9 00001435            833              LEA     d2MSG, A0    ;load message "D2"
00001E5C  4EB9 00001102            834              JSR     ADD2BUFFER  ;add it to printBuffer
00001E62  41F9 000012F0            835              LEA     forwardSlash, A0    ;load "/"
00001E68  4EB9 00001102            836              JSR     ADD2BUFFER  ;add it to printBuffer
00001E6E                           837              *continue with next bit check
00001E6E                           838  movem_postD3
00001E6E  3803                     839              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001E70  103C 0003                840              MOVE.B  #3, D0     ;shift count for D4
00001E74  E0AC                     841              LSR.L   D0, D4      ;shift bit 12 to the far right to isolate for decoding D3
00001E76  C8BC 00000001            842              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001E7C                           843              
00001E7C  B83C 0001                844              CMP.B   #1, D4     ;is bit set?
00001E80  6600 001A                845              BNE     movem_postD4
00001E84                           846              
00001E84  41F9 00001438            847              LEA     d3MSG, A0    ;load message "D3"
00001E8A  4EB9 00001102            848              JSR     ADD2BUFFER  ;add it to printBuffer
00001E90  41F9 000012F0            849              LEA     forwardSlash, A0    ;load "/"
00001E96  4EB9 00001102            850              JSR     ADD2BUFFER  ;add it to printBuffer
00001E9C                           851              *continue with next bit check
00001E9C                           852  movem_postD4
00001E9C  3803                     853              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001E9E  103C 0004                854              MOVE.B  #4, D0      ;shift count for D4
00001EA2  E0AC                     855              LSR.L   D0, D4      ;shift bit 9 to the far right to isolate for decoding D6
00001EA4  C8BC 00000001            856              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001EAA                           857              
00001EAA  B83C 0001                858              CMP.B   #1, D4     ;is bit set?
00001EAE  6600 001A                859              BNE     movem_postD5
00001EB2                           860              
00001EB2  41F9 0000143B            861              LEA     d4MSG, A0    ;load message "D6"
00001EB8  4EB9 00001102            862              JSR     ADD2BUFFER  ;add it to printBuffer
00001EBE  41F9 000012F0            863              LEA     forwardSlash, A0    ;load "/"
00001EC4  4EB9 00001102            864              JSR     ADD2BUFFER  ;add it to printBuffer
00001ECA                           865              *continue with next bit check
00001ECA                           866  movem_postD5
00001ECA  3803                     867              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001ECC  103C 0005                868              MOVE.B  #5, D0     ;shift count for D4
00001ED0  E0AC                     869              LSR.L   D0, D4      ;shift bit 10 to the far right to isolate for decoding D5
00001ED2  C8BC 00000001            870              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001ED8                           871              
00001ED8  B83C 0001                872              CMP.B   #1, D4     ;is bit set?
00001EDC  6600 001A                873              BNE     movem_postD6
00001EE0                           874              
00001EE0  41F9 0000143E            875              LEA     d5MSG, A0    ;load message "D5"
00001EE6  4EB9 00001102            876              JSR     ADD2BUFFER  ;add it to printBuffer
00001EEC  41F9 000012F0            877              LEA     forwardSlash, A0    ;load "/"
00001EF2  4EB9 00001102            878              JSR     ADD2BUFFER  ;add it to printBuffer
00001EF8                           879              *continue with next bit check           
00001EF8                           880  movem_postD6
00001EF8  3803                     881              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001EFA  103C 0006                882              MOVE.B  #6, D0      ;shift count for D4
00001EFE  E0AC                     883              LSR.L   D0, D4      ;shift bit 9 to the far right to isolate for decoding D6
00001F00  C8BC 00000001            884              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001F06                           885              
00001F06  B83C 0001                886              CMP.B   #1, D4     ;is bit set?
00001F0A  6600 001A                887              BNE     movem_postD7
00001F0E                           888              
00001F0E  41F9 00001441            889              LEA     d6MSG, A0    ;load message "D6"
00001F14  4EB9 00001102            890              JSR     ADD2BUFFER  ;add it to printBuffer
00001F1A  41F9 000012F0            891              LEA     forwardSlash, A0    ;load "/"
00001F20  4EB9 00001102            892              JSR     ADD2BUFFER  ;add it to printBuffer
00001F26                           893              *continue with next bit check
00001F26                           894  movem_postD7
00001F26  3803                     895              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001F28  103C 0007                896              MOVE.B  #7, D0     ;shift count for D4
00001F2C  E0AC                     897              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding D7
00001F2E  C8BC 00000001            898              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001F34                           899              
00001F34  B83C 0001                900              CMP.B   #1, D4     ;is bit set?
00001F38  6600 001A                901              BNE     movem_postA0
00001F3C                           902              
00001F3C  41F9 00001444            903              LEA     d7MSG, A0    ;load message "D7"
00001F42  4EB9 00001102            904              JSR     ADD2BUFFER  ;add it to printBuffer
00001F48  41F9 000012F0            905              LEA     forwardSlash, A0    ;load "/"
00001F4E  4EB9 00001102            906              JSR     ADD2BUFFER  ;add it to printBuffer
00001F54                           907              *continue with next bit check
00001F54                           908  movem_postA0
00001F54  3803                     909              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001F56  103C 0008                910              MOVE.B  #8, D0     ;shift count for A0
00001F5A  E0AC                     911              LSR.L   D0, D4      ;shift bit 7 to the far right to isolate for decoding A0
00001F5C  C8BC 00000001            912              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001F62                           913              
00001F62  B83C 0001                914              CMP.B   #1, D4     ;is bit set?
00001F66  6600 001A                915              BNE     movem_postA1
00001F6A                           916              
00001F6A  41F9 00001447            917              LEA     ar0MSG, A0    ;load message "A0"
00001F70  4EB9 00001102            918              JSR     ADD2BUFFER  ;add it to printBuffer
00001F76  41F9 000012F0            919              LEA     forwardSlash, A0    ;load "/"
00001F7C  4EB9 00001102            920              JSR     ADD2BUFFER  ;add it to printBuffer
00001F82                           921              *continue with next bit check
00001F82                           922  movem_postA1
00001F82  3803                     923              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001F84  103C 0009                924              MOVE.B  #9, D0     ;shift count for A1
00001F88  E0AC                     925              LSR.L   D0, D4      ;shift bit 6 to the far right to isolate for decoding A1
00001F8A  C8BC 00000001            926              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001F90                           927              
00001F90  B83C 0001                928              CMP.B   #1, D4     ;is bit set?
00001F94  6600 001A                929              BNE     movem_postA2
00001F98                           930              
00001F98  41F9 0000144A            931              LEA     ar1MSG, A0    ;load message "A1"
00001F9E  4EB9 00001102            932              JSR     ADD2BUFFER  ;add it to printBuffer
00001FA4  41F9 000012F0            933              LEA     forwardSlash, A0    ;load "/"
00001FAA  4EB9 00001102            934              JSR     ADD2BUFFER  ;add it to printBuffer
00001FB0                           935              *continue with next bit check 
00001FB0                           936  movem_postA2
00001FB0  3803                     937              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001FB2  103C 000A                938              MOVE.B  #10, D0      ;shift count for A2
00001FB6  E0AC                     939              LSR.L   D0, D4      ;shift bit 5 to the far right to isolate for decoding A2
00001FB8  C8BC 00000001            940              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001FBE                           941              
00001FBE  B83C 0001                942              CMP.B   #1, D4     ;is bit set?
00001FC2  6600 001A                943              BNE     movem_postA3
00001FC6                           944              
00001FC6  41F9 0000144D            945              LEA     ar2MSG, A0    ;load message "A2"
00001FCC  4EB9 00001102            946              JSR     ADD2BUFFER  ;add it to printBuffer
00001FD2  41F9 000012F0            947              LEA     forwardSlash, A0    ;load "/"
00001FD8  4EB9 00001102            948              JSR     ADD2BUFFER  ;add it to printBuffer
00001FDE                           949              *continue with next bit check
00001FDE                           950  movem_postA3
00001FDE  3803                     951              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00001FE0  103C 000B                952              MOVE.B  #11, D0      ;shift count for A3
00001FE4  E0AC                     953              LSR.L   D0, D4      ;shift bit 4 to the far right to isolate for decoding A3
00001FE6  C8BC 00000001            954              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00001FEC                           955              
00001FEC  B83C 0001                956              CMP.B   #1, D4     ;is bit set?
00001FF0  6600 001A                957              BNE     movem_postA4
00001FF4                           958              
00001FF4  41F9 00001450            959              LEA     ar3MSG, A0    ;load message "A3"
00001FFA  4EB9 00001102            960              JSR     ADD2BUFFER  ;add it to printBuffer
00002000  41F9 000012F0            961              LEA     forwardSlash, A0    ;load "/"
00002006  4EB9 00001102            962              JSR     ADD2BUFFER  ;add it to printBuffer
0000200C                           963              *continue with next bit check
0000200C                           964  movem_postA4
0000200C  3803                     965              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
0000200E  103C 000C                966              MOVE.B  #12, D0     ;shift count for A4
00002012  E0AC                     967              LSR.L   D0, D4      ;shift bit 3 to the far right to isolate for decoding A4
00002014  C8BC 00000001            968              AND.L   #1, D4      ;mask uneeded bits/set to zeros
0000201A                           969              
0000201A  B83C 0001                970              CMP.B   #1, D4     ;is bit set?
0000201E  6600 001A                971              BNE     movem_postA5
00002022                           972              
00002022  41F9 00001453            973              LEA     ar4MSG, A0    ;load message "A4"
00002028  4EB9 00001102            974              JSR     ADD2BUFFER  ;add it to printBuffer
0000202E  41F9 000012F0            975              LEA     forwardSlash, A0    ;load "/"
00002034  4EB9 00001102            976              JSR     ADD2BUFFER  ;add it to printBuffer
0000203A                           977              *continue with next bit check
0000203A                           978  movem_postA5
0000203A  3803                     979              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
0000203C  103C 000D                980              MOVE.B  #13, D0     ;shift count for A5
00002040  E0AC                     981              LSR.L   D0, D4      ;shift bit 2 to the far right to isolate for decoding A5
00002042  C8BC 00000001            982              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00002048                           983              
00002048  B83C 0001                984              CMP.B   #1, D4     ;is bit set?
0000204C  6600 001A                985              BNE     movem_postA6
00002050                           986              
00002050  41F9 00001456            987              LEA     ar5MSG, A0    ;load message "A5"
00002056  4EB9 00001102            988              JSR     ADD2BUFFER  ;add it to printBuffer
0000205C  41F9 000012F0            989              LEA     forwardSlash, A0    ;load "/"
00002062  4EB9 00001102            990              JSR     ADD2BUFFER  ;add it to printBuffer
00002068                           991              *continue with next bit check
00002068                           992  movem_postA6
00002068  3803                     993              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
0000206A  103C 000E                994              MOVE.B  #14, D0     ;shift count for A6
0000206E  E0AC                     995              LSR.L   D0, D4      ;shift bit 1 to the far right to isolate for decoding A6
00002070  C8BC 00000001            996              AND.L   #1, D4      ;mask uneeded bits/set to zeros
00002076                           997              
00002076  B83C 0001                998              CMP.B   #1, D4     ;is bit set?
0000207A  6600 001A                999              BNE     movem_postA7
0000207E                          1000              
0000207E  41F9 00001459           1001              LEA     ar6MSG, A0    ;load message "A6"
00002084  4EB9 00001102           1002              JSR     ADD2BUFFER  ;add it to printBuffer
0000208A  41F9 000012F0           1003              LEA     forwardSlash, A0    ;load "/"
00002090  4EB9 00001102           1004              JSR     ADD2BUFFER  ;add it to printBuffer
00002096                          1005              *continue with next bit check
00002096                          1006  movem_postA7
00002096  3803                    1007              MOVE.W  D3, D4      ;make a temp copy in D4 for manipulation
00002098  103C 000F               1008              MOVE.B  #15, D0     ;shift count for A6
0000209C  E0AC                    1009              LSR.L   D0, D4      ;shift bit 1 to the far right to isolate for decoding A7
0000209E  C8BC 00000001           1010              AND.L   #1, D4      ;mask uneeded bits/set to zeros
000020A4                          1011              
000020A4                          1012              
000020A4  B83C 0001               1013              CMP.B   #1, D4     ;is bit set?
000020A8  6600 000E               1014              BNE     movem_postEnd
000020AC                          1015              
000020AC  41F9 0000145C           1016              LEA     ar7MSG, A0    ;load message "A7"
000020B2  4EB9 00001102           1017              JSR     ADD2BUFFER  ;add it to printBuffer
000020B8                          1018              *end of bit read
000020B8                          1019  movem_postEnd
000020B8  4E75                    1020              RTS         ;return to movem caller
000020BA                          1021  
000020BA                          1022   
000020BA                          1023  
000020BA                          1024  
000020BA                          1025  decLEA: 
000020BA  41F9 00001349           1026              LEA     leaMSG, A0     ;load message "LEA"
000020C0  4EB9 00001102           1027              JSR     ADD2BUFFER     ;add message to printBuffer
000020C6  41F9 000012F2           1028              LEA     space, A0      ;load text spaceing
000020CC  4EB9 00001102           1029              JSR     ADD2BUFFER     ;add message to printBuffer
000020D2  4EB9 00002F4E           1030              JSR     EA          ;jump to EA.X68 to decode source EA and append to printBuffer
000020D8  41F9 000012E9           1031              LEA     comma, A0   ;load ", "
000020DE  4EB9 00001102           1032              JSR     ADD2BUFFER  ;add message to printBuffer
000020E4                          1033              
000020E4  4EB9 00002D22           1034              JSR     DECODE_AN   ;find destination address register and add to printBuffer
000020EA                          1035              
000020EA  4E75                    1036              RTS                 ;return to MAIN.X68 for printing   
000020EC                          1037  
000020EC                          1038    
000020EC                          1039  decCHK:
000020EC  41F9 00001350           1040              LEA     chkMSG, A0     ;load message "CHK"
000020F2  4EB9 00001102           1041              JSR     ADD2BUFFER     ;add message to printBuffer
000020F8                          1042  
000020F8  3803                    1043              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000020FA  103C 0007               1044              MOVE.B  #7, D0      ;shift count for D4
000020FE  E0AC                    1045              LSR.L   D0, D4      ;shift bits 8-7 to the far right to isolate for decoding Address reg
00002100  C8BC 00000003           1046              AND.L   #3, D4      ;mask uneeded bits/set to zeros
00002106                          1047              
00002106  B83C 0003               1048              CMP.B   #3, D4      ;is the size a word?
0000210A  6700 0010               1049              BEQ     load_w
0000210E  B83C 0002               1050              CMP.B   #2, D4      ;is the size a long?
00002112  6700 001E               1051              BEQ     load_l
00002116                          1052              
00002116  4EF9 00002BB6           1053              JMP     BADFLAG     ;can't decode if it's not one of those
0000211C                          1054  load_w:     
0000211C  1C3C 0010               1055              MOVE.B  #16, D6       ;set size for EA to decode immediate data
00002120  41F9 00001427           1056              LEA     wordMSG, A0   ;load ".W " message
00002126  4EB9 00001102           1057              JSR     ADD2BUFFER    ;add message to printBuffer
0000212C  4EF9 00002142           1058              JMP     endCHK        ;finish the decode
00002132                          1059              
00002132                          1060  load_l:                 
00002132  1C3C 0020               1061              MOVE.B  #32, D6       ;set size for EA to decode immediate data
00002136  41F9 0000142B           1062              LEA     longMSG, A0   ;load ".L " message
0000213C  4EB9 00001102           1063              JSR     ADD2BUFFER    ;add message to printBuffer
00002142                          1064  
00002142                          1065  endCHK:            
00002142  4EB9 00002F4E           1066              JSR     EA          ;jump to EA.X68 to decode source EA and append to printBuffer
00002148  41F9 000012E9           1067              LEA     comma, A0   ;load ", "
0000214E  4EB9 00001102           1068              JSR     ADD2BUFFER  ;add message to printBuffer
00002154  4EB9 00002BBC           1069              JSR     DECODE_DN   ;find destination data register and add to printBuffer
0000215A                          1070              
0000215A  4E75                    1071              RTS                 ;return to MAIN.X68 for printing     
0000215C                          1072  
0000215C                          1073  
0000215C                          1074  decSUBQ:    
0000215C  41F9 0000135D           1075              LEA     subqMSG, A0 ;load "SUBQ" message
00002162  4EB9 00001102           1076              JSR     ADD2BUFFER  ;put message in printBuffer
00002168  4EB9 00002DD8           1077              JSR     GET_SIZE    ;get the size and append it to printBuffer
0000216E  41F9 000012EC           1078              LEA     hashtag, A0
00002174  4EB9 00001102           1079              JSR     ADD2BUFFER  ;append "#" to printBuffer
0000217A  41F9 000012EE           1080              LEA     hexSign, A0
00002180  4EB9 00001102           1081              JSR     ADD2BUFFER  ;append "$" to printBuffer
00002186                          1082              
00002186  3803                    1083              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002188  103C 0009               1084              MOVE.B  #9, D0      ;shift count for D4
0000218C  E0AC                    1085              LSR.L   D0, D4      ;shift bits 11-9 to the far right to isolate for decoding data
0000218E  C8BC 00000007           1086              AND.L   #7, D4      ;mask uneeded bits/set to zeros
00002194                          1087              
00002194  B83C 0000               1088              CMP.B   #0, D4       ;if it's zero, it needs to be adjusted to 8 first
00002198  6600 0004               1089              BNE     subq_hex_conv
0000219C  5004                    1090              ADDI.B  #8, D4       ;change to 8, then continue with hex conversion
0000219E                          1091  subq_hex_conv
0000219E  103C 0004               1092              MOVE.B  #4, D0      ;bit length for ascii conversion
000021A2  4EB9 0000110C           1093              JSR     HexToAscii  ;converted number loaded into hex2ascBuffer
000021A8  41F9 000012DE           1094              LEA     hex2ascBuffer, A0   ;load ascii buffer
000021AE  4EB9 00001102           1095              JSR     ADD2BUFFER  ;append ascii data to printBuffer
000021B4  41F9 000012E9           1096              LEA     comma, A0   ;load ", "
000021BA  4EB9 00001102           1097              JSR     ADD2BUFFER  ;add message to printBuffer
000021C0                          1098              
000021C0  4EB9 00002F4E           1099              JSR     EA         ;jump to EA.X68 to decode destination EA and append to printBuffer
000021C6  4E75                    1100              RTS              ;return to MAIN.X68 for printing 
000021C8                          1101              
000021C8                          1102  
000021C8                          1103  
000021C8                          1104  decADDQ
000021C8  41F9 00001356           1105              LEA     addqMSG, A0 ;load "ADDQ" message
000021CE  4EB9 00001102           1106              JSR     ADD2BUFFER  ;put message in printBuffer
000021D4  4EB9 00002DD8           1107              JSR     GET_SIZE    ;get the size and append it to printBuffer
000021DA  41F9 000012EC           1108              LEA     hashtag, A0
000021E0  4EB9 00001102           1109              JSR     ADD2BUFFER  ;append "#" to printBuffer
000021E6  41F9 000012EE           1110              LEA     hexSign, A0
000021EC  4EB9 00001102           1111              JSR     ADD2BUFFER  ;append "$" to printBuffer
000021F2                          1112              
000021F2  3803                    1113              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000021F4  103C 0009               1114              MOVE.B  #9, D0      ;shift count for D4
000021F8  E0AC                    1115              LSR.L   D0, D4      ;shift bits 11-9 to the far right to isolate for decoding data
000021FA  C8BC 00000007           1116              AND.L   #7, D4      ;mask uneeded bits/set to zeros
00002200                          1117              
00002200  B83C 0000               1118              CMP.B   #0, D4       ;if it's zero, it needs to be adjusted to 8 first
00002204  6698                    1119              BNE     subq_hex_conv
00002206  5004                    1120              ADDI.B  #8, D4       ;change to 8, then continue with hex conversion
00002208                          1121  addq_hex_conv
00002208  103C 0004               1122              MOVE.B  #4, D0      ;bit length for ascii conversion
0000220C  4EB9 0000110C           1123              JSR     HexToAscii  ;converted number loaded into hex2ascBuffer
00002212  41F9 000012DE           1124              LEA     hex2ascBuffer, A0   ;load ascii buffer
00002218  4EB9 00001102           1125              JSR     ADD2BUFFER  ;append ascii data to printBuffer
0000221E  41F9 000012E9           1126              LEA     comma, A0   ;load ", "
00002224  4EB9 00001102           1127              JSR     ADD2BUFFER  ;add message to printBuffer
0000222A                          1128              
0000222A  4EB9 00002F4E           1129              JSR     EA         ;jump to EA.X68 to decode destination EA and append to printBuffer
00002230  4E75                    1130              RTS              ;return to MAIN.X68 for printing 
00002232                          1131  
00002232                          1132  
00002232                          1133  
00002232                          1134  BCC_DECODE: 
00002232                          1135              
00002232  B83C 0000               1136  decBRA      CMP.B   #0, D4   ;is it BRA?
00002236  6600 0012               1137              BNE     decBHI
0000223A  41F9 00001364           1138              LEA     braMSG, A0
00002240  4EB9 00001102           1139              JSR     ADD2BUFFER
00002246  6000 0146               1140              BRA     b_skip
0000224A                          1141              
0000224A  B83C 0002               1142  decBHI      CMP.B   #2, D4  ;is it BHI?
0000224E  6600 0012               1143              BNE     decBLS
00002252  41F9 0000138E           1144              LEA     bhiMSG, A0
00002258  4EB9 00001102           1145              JSR     ADD2BUFFER
0000225E  6000 012E               1146              BRA     b_skip       
00002262                          1147  
00002262  B83C 0003               1148  decBLS      CMP.B   #3, D4  ;is it BLS?
00002266  6600 0012               1149              BNE     decBCC
0000226A  41F9 0000139C           1150              LEA     blsMSG, A0
00002270  4EB9 00001102           1151              JSR     ADD2BUFFER
00002276  6000 0116               1152              BRA     b_skip
0000227A                          1153  
0000227A  B83C 0004               1154  decBCC      CMP.B   #4, D4  ;is it BCC?
0000227E  6600 0012               1155              BNE     decBCS
00002282  41F9 0000136B           1156              LEA     bccMSG, A0
00002288  4EB9 00001102           1157              JSR     ADD2BUFFER
0000228E  6000 00FE               1158              BRA     b_skip
00002292                          1159              
00002292  B83C 0005               1160  decBCS      CMP.B   #5, D4  ;is it BCS?
00002296  6600 0012               1161              BNE     decBNE
0000229A  41F9 00001372           1162              LEA     bcsMSG, A0
000022A0  4EB9 00001102           1163              JSR     ADD2BUFFER
000022A6  6000 00E6               1164              BRA     b_skip
000022AA                          1165  
000022AA  B83C 0006               1166  decBNE      CMP.B   #6, D4  ;is it BNE?
000022AE  6600 0012               1167              BNE     decBEQ
000022B2  41F9 000013B1           1168              LEA     bneMSG, A0
000022B8  4EB9 00001102           1169              JSR     ADD2BUFFER
000022BE  6000 00CE               1170              BRA     b_skip
000022C2                          1171              
000022C2  B83C 0007               1172  decBEQ      CMP.B   #7, D4  ;is it BEQ?
000022C6  6600 0012               1173              BNE     decBVC
000022CA  41F9 00001379           1174              LEA     beqMSG, A0
000022D0  4EB9 00001102           1175              JSR     ADD2BUFFER
000022D6  6000 00B6               1176              BRA     b_skip
000022DA                          1177              
000022DA  B83C 0008               1178  decBVC      CMP.B   #8, D4  ;is it BVC?
000022DE  6600 0012               1179              BNE     decBVS
000022E2  41F9 000013BF           1180              LEA     bvcMSG, A0
000022E8  4EB9 00001102           1181              JSR     ADD2BUFFER
000022EE  6000 009E               1182              BRA     b_skip
000022F2                          1183              
000022F2  B83C 0009               1184  decBVS      CMP.B   #9, D4  ;is it BVS?
000022F6  6600 0012               1185              BNE     decBPL
000022FA  41F9 000013C6           1186              LEA     bvsMSG, A0
00002300  4EB9 00001102           1187              JSR     ADD2BUFFER
00002306  6000 0086               1188              BRA     b_skip
0000230A                          1189              
0000230A  B83C 000A               1190  decBPL      CMP.B   #10, D4  ;is it BPL?
0000230E  6600 0012               1191              BNE     decBMI
00002312  41F9 000013B8           1192              LEA     bplMSG, A0
00002318  4EB9 00001102           1193              JSR     ADD2BUFFER
0000231E  6000 006E               1194              BRA     b_skip
00002322                          1195  
00002322  B83C 000B               1196  decBMI      CMP.B   #11, D4  ;is it BMI?
00002326  6600 0012               1197              BNE     decBGE
0000232A  41F9 000013AA           1198              LEA     bmiMSG, A0
00002330  4EB9 00001102           1199              JSR     ADD2BUFFER
00002336  6000 0056               1200              BRA     b_skip
0000233A                          1201  
0000233A  B83C 000C               1202  decBGE      CMP.B   #12, D4  ;is it BGE? 
0000233E  6600 0012               1203              BNE     decBLT
00002342  41F9 00001380           1204              LEA     bgeMSG, A0
00002348  4EB9 00001102           1205              JSR     ADD2BUFFER
0000234E  6000 003E               1206              BRA     b_skip
00002352                          1207  
00002352  B83C 000D               1208  decBLT      CMP.B   #13, D4  ;is it BLT?
00002356  6600 0012               1209              BNE     decBGT
0000235A  41F9 000013A3           1210              LEA     bltMSG, A0
00002360  4EB9 00001102           1211              JSR     ADD2BUFFER
00002366  6000 0026               1212              BRA     b_skip
0000236A                          1213  
0000236A  B83C 000E               1214  decBGT      CMP.B   #14, D4  ;is it BGT?
0000236E  6600 0012               1215              BNE     decBLE
00002372  41F9 00001387           1216              LEA     bgtMSG, A0
00002378  4EB9 00001102           1217              JSR     ADD2BUFFER
0000237E  6000 000E               1218              BRA     b_skip
00002382                          1219              
00002382  41F9 00001395           1220  decBLE      LEA     bleMSG, A0 ;it has to be BLE then
00002388  4EB9 00001102           1221              JSR     ADD2BUFFER
0000238E                          1222              
0000238E                          1223  
0000238E  41F9 000012EE           1224  b_skip      LEA     hexSign, A0 ;append "$" to printBuffer
00002394  4EB9 00001102           1225              JSR     ADD2BUFFER
0000239A                          1226              
0000239A  4284                    1227              CLR.L   D4              ;clear register  
0000239C  4280                    1228              CLR.L   D0              ;clear register
0000239E  3803                    1229              MOVE.W  D3, D4       ;make a temp copy of opword in D4 for manipulation
000023A0  C8BC 000000FF           1230              AND.L   #$FF, D4      ;mask uneeded bits/set to zeros to isolate for decoding displacement size
000023A6                          1231  
000023A6                          1232              
000023A6  B83C 0000               1233  word_dsp    CMP.B   #$0, D4     ;word displacement?
000023AA  6600 0022               1234              BNE     long_dsp  
000023AE                          1235              
000023AE  384B                    1236              MOVE.W  A3, A4          ;update address pointer incase opcode still can't be decoded at some point
000023B0  361B                    1237              MOVE.W  (A3)+, D3       ;grab the displacement data from the WORD after the opcode
000023B2  3803                    1238              MOVE.W  D3, D4          ;make a temp copy in D4 for manipulation
000023B4  D84C                    1239              ADD.W   A4, D4          ;add program pointer to Displacement(opcode addr +2, ie A4 after postincrement)
000023B6                          1240    
000023B6  103C 0010               1241              MOVE.B  #16, D0         ;load length of hex value
000023BA  4EB9 0000110C           1242              JSR     HexToAscii      ;convert to ascii, puts in hex2ascBuffer
000023C0  41F9 000012DE           1243              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
000023C6  4EB9 00001102           1244              JSR     ADD2BUFFER      ;append to printBuffer
000023CC  4E75                    1245              RTS         ;return to MAIN.X68 for printing    
000023CE                          1246              
000023CE  B83C 00FF               1247  long_dsp    CMP.B   #$FF,D4         ;long displacement?
000023D2  6600 0022               1248              BNE     byte_dsp
000023D6                          1249              
000023D6  384B                    1250              MOVE.W  A3, A4          ;update address pointer incase opcode still can't be decoded at some point
000023D8  261B                    1251              MOVE.L  (A3)+, D3       ;grab the displacement data from the LONG after the opcode
000023DA  2803                    1252              MOVE.L  D3, D4          ;make a temp copy in D4 for manipulation
000023DC  D88C                    1253              ADD.L   A4, D4          ;add program pointer to Displacement(opcode addr +2, ie A4 after postincrement)            
000023DE                          1254              
000023DE  103C 0020               1255              MOVE.B  #32, D0         ;load length of hex value
000023E2  4EB9 0000110C           1256              JSR     HexToAscii      ;convert to ascii, puts in hex2ascBuffer
000023E8  41F9 000012DE           1257              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
000023EE  4EB9 00001102           1258              JSR     ADD2BUFFER      ;append to printBuffer
000023F4  4E75                    1259              RTS         ;return to MAIN.X68 for printing
000023F6                          1260              
000023F6                          1261  byte_dsp          ;byte displacement then
000023F6  4884                    1262              EXT.W   D4
000023F8  D84B                    1263              ADD.W   A3, D4          ;add program pointer to Displacement(opcode addr +2, ie A3)
000023FA  103C 0010               1264              MOVE.B  #16,D0           ;load length of hex value
000023FE  4EB9 0000110C           1265              JSR     HexToAscii      ;convert to ascii, puts in hex2ascBuffer
00002404  41F9 000012DE           1266              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
0000240A  4EB9 00001102           1267              JSR     ADD2BUFFER      ;append to printBuffer
00002410  4E75                    1268              RTS         ;return to MAIN.X68 for printing 
00002412                          1269  
00002412                          1270  
00002412                          1271  
00002412                          1272  decDIVS:
00002412  41F9 000013CD           1273              LEA     divsMSG, A0   ;load "DIVS" message
00002418  4EB9 00001102           1274              JSR     ADD2BUFFER  ;put it in the printBuffer
0000241E                          1275              
0000241E  3803                    1276              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002420  103C 0008               1277              MOVE.B  #8, D0      ;shift count for D4
00002424  E0AC                    1278              LSR.L   D0, D4      ;shift bit 8 to far right to isolate for last check it is actually DIVS
00002426  C8BC 00000001           1279              AND.L   #1, D4      ;mask uneeded bits/set to zeros
0000242C  B83C 0001               1280              CMP.B   #1, D4      ;is it DIVS?
00002430  6600 0784               1281              BNE     BADFLAG     ;if not, can't be decoded
00002434                          1282              
00002434  41F9 00001427           1283              LEA     wordMSG, A0 ;load ".W " message
0000243A  4EB9 00001102           1284              JSR     ADD2BUFFER  ;append to printBuffer
00002440  4EB9 00002F4E           1285              JSR     EA          ;jump to EA.X68 to decode source EA and append to printBuffer
00002446  41F9 000012E9           1286              LEA     comma, A0   ;load a comma ", "
0000244C  4EB9 00001102           1287              JSR     ADD2BUFFER  ;append to printBuffer            
00002452  4EB9 00002BBC           1288              JSR     DECODE_DN   ;decode destination data register, append to printBuffer
00002458  4E75                    1289              RTS         ;return to MAIN.X68 for printing 
0000245A                          1290  
0000245A                          1291              
0000245A                          1292  
0000245A                          1293  
0000245A                          1294  decOR:
0000245A  41F9 000013D4           1295              LEA     orMSG, A0   ;load "OR" message
00002460  4EB9 00001102           1296              JSR     ADD2BUFFER  ;put it in the printBuffer
00002466                          1297              
00002466  B83C 0000               1298              CMP.B   #0, D4  ;is the size .B?
0000246A  6600 0016               1299              BNE     o_skip1  ;skip to next cmp if not   
0000246E                          1300              
0000246E  1C3C 0008               1301              MOVE.B  #8, D6     ;set size for EA decoing
00002472  41F9 00001423           1302              LEA     byteMSG, A0  ;load ".B " message
00002478  4EB9 00001102           1303              JSR     ADD2BUFFER  ;append it to printBuffer
0000247E  6000 002E               1304              BRA     o_direction ;skip to decoding the EA direction
00002482                          1305  o_skip1
00002482  B83C 0001               1306              CMP.B   #1, D4  ;is the size .W?
00002486  6600 0016               1307              BNE     o_skip2  ;skip to next cmp if not   
0000248A                          1308              
0000248A  1C3C 0010               1309              MOVE.B  #16, D6     ;set size for EA decoing
0000248E  41F9 00001427           1310              LEA     wordMSG, A0  ;load ".W " message
00002494  4EB9 00001102           1311              JSR     ADD2BUFFER  ;append it to printBuffer
0000249A  6000 0012               1312              BRA     o_direction ;skip to decoding the EA direction
0000249E                          1313  o_skip2
0000249E  1C3C 0020               1314              MOVE.B  #32, D6     ;set size for EA decoing
000024A2  41F9 0000142B           1315              LEA     longMSG, A0  ;else it has to be a .L, load ".L " message
000024A8  4EB9 00001102           1316              JSR     ADD2BUFFER  ;append it to printBuffer
000024AE                          1317  
000024AE                          1318  o_direction
000024AE  3803                    1319              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000024B0  103C 0008               1320              MOVE.B  #8, D0      ;shift count for D4
000024B4  E0AC                    1321              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding EA order
000024B6  C8BC 00000001           1322              AND.L   #1, D4      ;mask uneeded bits/set to zeros
000024BC                          1323  
000024BC  B83C 0000               1324  o_mem2reg   CMP.B   #0, D4    ;is it <ea> -> Dn?
000024C0  6600 001C               1325              BNE     o_reg2mem ;if not, skip 
000024C4                          1326              
000024C4  4EB9 00002F4E           1327              JSR     EA         ;jump to EA.X68 to decode source EA and append to printBuffer
000024CA  41F9 000012E9           1328              LEA     comma, A0   ;load a comma ", " 
000024D0  4EB9 00001102           1329              JSR     ADD2BUFFER  ;append it to printBuffer
000024D6  4EB9 00002BBC           1330              JSR     DECODE_DN   ;find destination data register and add to printBuffer
000024DC                          1331              
000024DC  4E75                    1332              RTS                 ;return to MAIN.X68 for printing 
000024DE                          1333              
000024DE                          1334  o_reg2mem   *must be Dn -> <ea>
000024DE  4EB9 00002BBC           1335              JSR     DECODE_DN   ;find source data register and add to printBuffer
000024E4  41F9 000012E9           1336              LEA     comma, A0   ;load a comma ", "
000024EA  4EB9 00001102           1337              JSR     ADD2BUFFER  ;append it to printBuffer
000024F0  4EB9 00002F4E           1338              JSR     EA         ;jump to EA.X68 to decode destination EA and append to printBuffer
000024F6                          1339              
000024F6  4E75                    1340              RTS                 ;return to MAIN.X68 for printing    
000024F8                          1341  
000024F8                          1342            
000024F8                          1343  decSUB:
000024F8  41F9 000013D9           1344              LEA     subMSG, A0  ;load "SUB" message
000024FE  4EB9 00001102           1345              JSR     ADD2BUFFER  ;add it to printBuffer
00002504  4EB9 00002DD8           1346              JSR     GET_SIZE    ;get and load the size into printBuffer (.b, .w, .l)
0000250A                          1347              
0000250A  3803                    1348              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
0000250C  103C 0008               1349              MOVE.B  #8, D0      ;shift count for D4
00002510  E0AC                    1350              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding addressing direction
00002512  C8BC 00000001           1351              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
00002518                          1352  
00002518  B83C 0000               1353              CMP.B   #0, D4        ;is it (DN - <ea>) -> DN?
0000251C  6600 001C               1354              BNE     ED2E ;if no, skip to (<ea> - DN) -> <ea> direction
00002520                          1355              *(DN - <ea>) -> DN direction
00002520  4EB9 00002F4E           1356              JSR     EA      ;jump to EA code for decoding source EA and appending to printBuffer
00002526  41F9 000012E9           1357              LEA     comma, A0   ;load a comma ", "
0000252C  4EB9 00001102           1358              JSR     ADD2BUFFER  ;append to printBuffer
00002532  4EB9 00002BBC           1359              JSR     DECODE_DN   ;decode destination data register, append to printBuffer
00002538                          1360              
00002538  4E75                    1361              RTS         ;return to MAIN.X68
0000253A                          1362  ED2E:       *(<ea> - DN) -> <ea> direction
0000253A  4EB9 00002BBC           1363              JSR     DECODE_DN   ;decode source data register, append to printBuffer
00002540  41F9 000012E9           1364              LEA     comma, A0   ;load a comma ", "
00002546  4EB9 00001102           1365              JSR     ADD2BUFFER  ;append to printBuffer
0000254C  4EB9 00002F4E           1366              JSR     EA      ;jump to EA code for decoding destination EA and appending to printBuffer
00002552                          1367              
00002552  4E75                    1368              RTS         ;return to MAIN.X68
00002554                          1369  
00002554                          1370  
00002554                          1371  
00002554                          1372  decEOR:
00002554  41F9 000013DF           1373              LEA     eorMSG, A0          ;load "EOR" message
0000255A  4EB9 00001102           1374              JSR     ADD2BUFFER          ;add it to printBuffer
00002560  4EB9 00002DD8           1375              JSR     GET_SIZE            ;get and load the size into printBuffer (.b, .w, .l)
00002566  4EB9 00002BBC           1376              JSR     DECODE_DN           ;ecode source data register, append to printBuffer
0000256C  41F9 000012E9           1377              LEA     comma, A0           ;load a comma ", "
00002572  4EB9 00001102           1378              JSR     ADD2BUFFER          ;append to printBuffer
00002578  4EB9 00002F4E           1379              JSR     EA                  ;jump to EA code for decoding destination EA and appending to printBuffer
0000257E                          1380              
0000257E  4E75                    1381              RTS         ;return to MAIN.X68
00002580                          1382  
00002580                          1383  decCMP:
00002580  41F9 000013E5           1384              LEA     cmpMSG, A0          ;load "CMP" message
00002586  4EB9 00001102           1385              JSR     ADD2BUFFER          ;add it to printBuffer
0000258C  4EB9 00002DD8           1386              JSR     GET_SIZE            ;get and load the size into printBuffer (.b, .w, .l)
00002592  4EB9 00002F4E           1387              JSR     EA                  ;jump to EA code for decoding source EA and appending to printBuffer
00002598  41F9 000012E9           1388              LEA     comma, A0           ;load a comma ", "
0000259E  4EB9 00001102           1389              JSR     ADD2BUFFER          ;append to printBuffer
000025A4  4EB9 00002BBC           1390              JSR     DECODE_DN           ;ecode destination data register, append to printBuffer
000025AA                          1391              
000025AA  4E75                    1392              RTS         ;return to MAIN.X68
000025AC                          1393  
000025AC                          1394  
000025AC                          1395  decMULS:
000025AC  3803                    1396              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000025AE  103C 0006               1397              MOVE.B  #6, D0      ;shift count for D4
000025B2  E0AC                    1398              LSR.L   D0, D4      ;shift bits 7-6 to the far right to isolate for decoding            AND.L   #$3, D4      ;mask uneeded bits/set to zeros
000025B4  C8BC 00000007           1399              AND.L   #$7, D4      ;mask uneeded bits/set to zeros
000025BA                          1400  
000025BA  B83C 0007               1401              CMP.B   #7, D4      ;is it for sure MULS?
000025BE  6600 05F6               1402              BNE     BADFLAG     ;if not, can't decode 
000025C2                          1403              
000025C2  41F9 000013EB           1404              LEA     mulsMSG, A0  ;load "SUB" message
000025C8  4EB9 00001102           1405              JSR     ADD2BUFFER  ;add it to printBuffer
000025CE  41F9 00001427           1406              LEA     wordMSG, A0 ;load ".W "
000025D4  4EB9 00001102           1407              JSR     ADD2BUFFER  ;append to printBuffer
000025DA  1C3C 0010               1408              MOVE.B  #16,D6      ;set up size for EA decodeing
000025DE  4EB9 00002F4E           1409              JSR     EA      ;jump to EA code for decoding source EA and appending to printBuffer
000025E4  41F9 000012E9           1410              LEA     comma, A0           ;load a comma ", "
000025EA  4EB9 00001102           1411              JSR     ADD2BUFFER          ;append to printBuffer
000025F0  4EB9 00002BBC           1412              JSR     DECODE_DN   ;decode destination data register, append to printBuffer
000025F6                          1413              
000025F6  4E75                    1414              RTS         ;return to Main.X68
000025F8                          1415              
000025F8                          1416              
000025F8                          1417  decADD:
000025F8  41F9 000013F2           1418              LEA     addMSG, A0  ;load "ADD" message
000025FE  4EB9 00001102           1419              JSR     ADD2BUFFER  ;add it to printBuffer
00002604  4EB9 00002DD8           1420              JSR     GET_SIZE    ;get and load the size into printBuffer (.b, .w, .l)
0000260A                          1421              
0000260A  3803                    1422              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
0000260C  103C 0008               1423              MOVE.B  #8, D0      ;shift count for D4
00002610  E0AC                    1424              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding addressing direction
00002612  C8BC 00000001           1425              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
00002618                          1426  
00002618  B83C 0000               1427              CMP.B   #0, D4        ;is it (DN - <ea>) -> DN?
0000261C  6600 001C               1428              BNE     D2E         ;if no, skip to (<ea>-DN)-><ea> direction
00002620                          1429              *(DN - <ea>) -> DN direction
00002620  4EB9 00002F4E           1430              JSR     EA          ;jump to EA code for decoding source EA and appending to printBuffer
00002626  41F9 000012E9           1431              LEA     comma, A0   ;load a comma ", "
0000262C  4EB9 00001102           1432              JSR     ADD2BUFFER  ;append to printBuffer
00002632  4EB9 00002BBC           1433              JSR     DECODE_DN   ;decode destination data register, append to printBuffer
00002638                          1434              
00002638  4E75                    1435              RTS                 ;return to MAIN.X68
0000263A                          1436              
0000263A                          1437  D2E:       *(<ea> - DN) -> <ea> direction
0000263A  4EB9 00002BBC           1438              JSR     DECODE_DN   ;decode source data register, append to printBuffer
00002640  41F9 000012E9           1439              LEA     comma, A0   ;load a comma ", "
00002646  4EB9 00001102           1440              JSR     ADD2BUFFER  ;append to printBuffer
0000264C  4EB9 00002F4E           1441              JSR     EA          ;jump to EA code for decoding destination EA and appending to printBuffer
00002652                          1442              
00002652  4E75                    1443              RTS                 ;return to MAIN.X68
00002654                          1444  
00002654                          1445              
00002654                          1446              
00002654                          1447  decADDA:
00002654  41F9 000013F8           1448              LEA     addaMSG, A0  ;load "ADDA" message
0000265A  4EB9 00001102           1449              JSR     ADD2BUFFER  ;add it to printBuffer
00002660                          1450  
00002660  3803                    1451              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002662  103C 0008               1452              MOVE.B  #8, D0      ;shift count for D4
00002666  E0AC                    1453              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding size
00002668  C8BC 00000001           1454              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
0000266E                          1455  
0000266E  B83C 0000               1456              CMP.B   #0, D4      ;is it .W?
00002672  6600 002C               1457              BNE     add_l       ;if no, skip to long
00002676                          1458              
00002676  41F9 00001427           1459              LEA     wordMSG, A0   ;load ".W " message
0000267C  4EB9 00001102           1460              JSR     ADD2BUFFER  
00002682  1C3C 0010               1461              MOVE.B  #16, D6     ;set size for EA decodeing
00002686  4EB9 00002F4E           1462              JSR     EA          ;jump to EA code for decoding source EA and appending to printBuffer
0000268C                          1463              
0000268C  41F9 000012E9           1464              LEA     comma, A0   ;load ", "
00002692  4EB9 00001102           1465              JSR     ADD2BUFFER  ;add message to printBuffer
00002698                          1466              
00002698  4EB9 00002D22           1467              JSR     DECODE_AN   ;decode destination address register, append to printBuffer
0000269E  4E75                    1468              RTS                 ;return to MAIN.X68
000026A0                          1469  add_l:
000026A0  41F9 0000142B           1470              LEA     longMSG, A0   ;load ".L " message
000026A6  4EB9 00001102           1471              JSR     ADD2BUFFER  ;append to printBuffer
000026AC  1C3C 0020               1472              MOVE.B  #32, D6     ;set size for EA decodeing
000026B0  4EB9 00002F4E           1473              JSR     EA          ;jump to EA code for decoding source EA and appending to printBuffer
000026B6                          1474  
000026B6  41F9 000012E9           1475              LEA     comma, A0   ;load ", "
000026BC  4EB9 00001102           1476              JSR     ADD2BUFFER  ;add message to printBuffer
000026C2                          1477  
000026C2  4EB9 00002D22           1478              JSR     DECODE_AN   ;decode destination address register, append to printBuffer
000026C8  4E75                    1479              RTS                 ;return to MAIN.X68
000026CA                          1480  
000026CA                          1481  
000026CA                          1482  
000026CA                          1483  
000026CA                          1484  
000026CA                          1485  
000026CA                          1486  
000026CA                          1487  decASL:
000026CA  3803                    1488              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000026CC  103C 0008               1489              MOVE.B  #8, D0      ;shift count for D4
000026D0  E0AC                    1490              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding size
000026D2  C8BC 00000001           1491              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
000026D8                          1492  
000026D8  B83C 0001               1493              CMP.B   #1, D4      ;is it rotate left?
000026DC  6600 0022               1494              BNE     decASR       ;if no, skip to ASR
000026E0                          1495              
000026E0  41F9 000013FF           1496              LEA     aslMSG, A0  ;load "ASL" message
000026E6  4EB9 00001102           1497              JSR     ADD2BUFFER  ;add it to printBuffer
000026EC  41F9 00001427           1498              LEA     wordMSG, A0   ;load ".W " message
000026F2  4EB9 00001102           1499              JSR     ADD2BUFFER  ;append to printBuffer
000026F8  4EB9 00002F4E           1500              JSR     EA          ;jump to EA code for decoding source EA and appending to printBuffer
000026FE  4E75                    1501              RTS              ;return to MAIN.X68
00002700                          1502  
00002700                          1503  decASR:
00002700  41F9 00001405           1504              LEA     asrMSG, A0  ;load "ASR" message
00002706  4EB9 00001102           1505              JSR     ADD2BUFFER  ;add it to printBuffer
0000270C  41F9 00001427           1506              LEA     wordMSG, A0   ;load ".W " message
00002712  4EB9 00001102           1507              JSR     ADD2BUFFER  ;append to printBuffer
00002718  4EB9 00002F4E           1508              JSR     EA          ;jump to EA code for decoding source EA and appending to printBuffer
0000271E  4E75                    1509              RTS              ;return to MAIN.X68
00002720                          1510  
00002720                          1511  
00002720                          1512  decASLreg:  *** Decode ASL with reg or immediate as shift count ***
00002720  3803                    1513              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002722  103C 0008               1514              MOVE.B  #8, D0      ;shift count for D4
00002726  E0AC                    1515              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding size
00002728  C8BC 00000001           1516              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
0000272E                          1517  
0000272E  B83C 0001               1518              CMP.B   #1, D4      ;is it rotate left?
00002732  6600 009E               1519              BNE     decASRreg    ;if no, skip to ASR
00002736                          1520              
00002736  41F9 000013FF           1521              LEA     aslMSG, A0  ;load "ASL" message
0000273C  4EB9 00001102           1522              JSR     ADD2BUFFER  ;add it to printBuffer
00002742  4EB9 00002DD8           1523              JSR     GET_SIZE    ;get and load the size into printBuffer (.b, .w, .l)
00002748                          1524              
00002748  3803                    1525              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
0000274A  103C 0005               1526              MOVE.B  #5, D0      ;shift count for D4
0000274E  E0AC                    1527              LSR.L   D0, D4      ;shift bit 5 to the far right to isolate for decoding shift count source
00002750  C8BC 00000001           1528              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
00002756                          1529  
00002756  B83C 0001               1530              CMP.B   #1, D4      ;is it data reg as shift count source?
0000275A  6600 001C               1531              BNE     asl_im      ;if no, skip to immediate shift count
0000275E                          1532              
0000275E  4EB9 00002BBC           1533              JSR     DECODE_DN   ;get data register as source and append to printBuffer
00002764  41F9 000012E9           1534              LEA     comma, A0   ;load ", "
0000276A  4EB9 00001102           1535              JSR     ADD2BUFFER  ;add message to printBuffer
00002770  4EB9 00002C72           1536              JSR     V2DECODE_DN   ;get data register as destination opperand and append to printBuffer
00002776  4E75                    1537              RTS                 ;return to MAIN.X68
00002778                          1538  
00002778                          1539  
00002778                          1540  asl_im              *find immediate shift number 
00002778  41F9 000012EC           1541              LEA     hashtag, A0 ;load "#" for immidiate
0000277E  4EB9 00001102           1542              JSR     ADD2BUFFER  ;append to printBuffer
00002784  41F9 000012EE           1543              LEA     hexSign, A0 ;load  "$" for hex
0000278A  4EB9 00001102           1544              JSR     ADD2BUFFER  ;append to printBuffer
00002790                          1545      
00002790  3803                    1546              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002792  103C 0009               1547              MOVE.B  #9, D0      ;shift count for D4
00002796  E0AC                    1548              LSR.L   D0, D4      ;shift bits 11-9 to the far right to isolate for decoding shift count (1-8)
00002798  C8BC 00000007           1549              AND.L   #$7, D4      ;mask uneeded bits/set to zeros
0000279E                          1550             
0000279E  B83C 0000               1551              CMP.B   #0, D4       ;if it's zero, it needs to be adjusted to 8 first
000027A2  6600 0004               1552              BNE     asl_hex_conv
000027A6  5004                    1553              ADDI.B  #8, D4       ;change to 8, then continue with hex conversion
000027A8                          1554  asl_hex_conv            
000027A8  103C 0008               1555              MOVE.B  #8,D0         ;load length of hex value
000027AC  4EB9 0000110C           1556              JSR     HexToAscii    ;convert num in D4 to ascii, puts in hex2ascBuffer
000027B2  41F9 000012DE           1557              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
000027B8  4EB9 00001102           1558              JSR     ADD2BUFFER      ;add immediate value to buffer
000027BE  41F9 000012E9           1559              LEA     comma, A0   ;load ", "
000027C4  4EB9 00001102           1560              JSR     ADD2BUFFER  ;add message to printBuffer
000027CA  4EB9 00002C72           1561              JSR     V2DECODE_DN     ;get data register as destination opperand and append to printBuffer
000027D0  4E75                    1562              RTS                 ;return to MAIN.X68
000027D2                          1563  
000027D2                          1564  
000027D2                          1565  
000027D2                          1566  
000027D2                          1567  decASRreg:  *** Decode ASR with reg or immediate as shift count ***
000027D2  41F9 00001405           1568              LEA     asrMSG, A0  ;load "ASR" message
000027D8  4EB9 00001102           1569              JSR     ADD2BUFFER  ;add it to printBuffer
000027DE  4EB9 00002DD8           1570              JSR     GET_SIZE    ;get and load the size into printBuffer (.b, .w, .l)
000027E4                          1571  
000027E4  3803                    1572              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000027E6  103C 0005               1573              MOVE.B  #5, D0      ;shift count for D4
000027EA  E0AC                    1574              LSR.L   D0, D4      ;shift bit 5 to the far right to isolate for decoding shift count source
000027EC  C8BC 00000001           1575              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
000027F2                          1576  
000027F2  B83C 0001               1577              CMP.B   #1, D4      ;is it data reg as shift count source?
000027F6  6600 001C               1578              BNE     asr_im    ;if no, skip to immediate shift count
000027FA                          1579              
000027FA  4EB9 00002BBC           1580              JSR     DECODE_DN   ;get data register as source and append to printBuffer
00002800  41F9 000012E9           1581              LEA     comma, A0   ;load ", "
00002806  4EB9 00001102           1582              JSR     ADD2BUFFER  ;add message to printBuffer
0000280C  4EB9 00002C72           1583              JSR     V2DECODE_DN   ;get data register as destination opperand and append to printBuffer
00002812  4E75                    1584              RTS                 ;return to MAIN.X68
00002814                          1585  
00002814                          1586  
00002814                          1587  asr_im              *find immediate shift number
00002814  41F9 000012EC           1588              LEA     hashtag, A0 ;load "#" for immidiate
0000281A  4EB9 00001102           1589              JSR     ADD2BUFFER  ;append to printBuffer
00002820  41F9 000012EE           1590              LEA     hexSign, A0 ;load  "$" for hex
00002826  4EB9 00001102           1591              JSR     ADD2BUFFER  ;append to printBuffer
0000282C                          1592       
0000282C  3803                    1593              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
0000282E  103C 0009               1594              MOVE.B  #9, D0      ;shift count for D4
00002832  E0AC                    1595              LSR.L   D0, D4      ;shift bits 11-9 to the far right to isolate for decoding shift count (1-8)
00002834  C8BC 00000007           1596              AND.L   #$7, D4      ;mask uneeded bits/set to zeros
0000283A                          1597             
0000283A  B83C 0000               1598              CMP.B   #0, D4       ;if it's zero, it needs to be adjusted to 8 first
0000283E  6600 0004               1599              BNE     asr_hex_conv
00002842  5004                    1600              ADDI.B  #8, D4       ;change to 8, then continue with hex conversion
00002844                          1601  asr_hex_conv            
00002844  103C 0008               1602              MOVE.B  #8,D0         ;load length of hex value
00002848  4EB9 0000110C           1603              JSR     HexToAscii    ;convert num in D4 to ascii, puts in hex2ascBuffer
0000284E  41F9 000012DE           1604              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
00002854  4EB9 00001102           1605              JSR     ADD2BUFFER      ;add immediate value to buffer
0000285A  41F9 000012E9           1606              LEA     comma, A0   ;load ", "
00002860  4EB9 00001102           1607              JSR     ADD2BUFFER  ;add message to printBuffer
00002866  4EB9 00002C72           1608              JSR     V2DECODE_DN     ;get data register as destination opperand and append to printBuffer
0000286C  4E75                    1609              RTS                 ;return to MAIN.X68
0000286E                          1610  
0000286E                          1611  
0000286E                          1612  
0000286E                          1613  decLSL:
0000286E  3803                    1614              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002870  103C 0008               1615              MOVE.B  #8, D0      ;shift count for D4
00002874  E0AC                    1616              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding size
00002876  C8BC 00000001           1617              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
0000287C                          1618  
0000287C  B83C 0001               1619              CMP.B   #1, D4      ;is it rotate left?
00002880  6600 0022               1620              BNE     decLSR       ;if no, skip to LSR
00002884                          1621              
00002884  41F9 0000140B           1622              LEA     lslMSG, A0  ;load "LSL" message
0000288A  4EB9 00001102           1623              JSR     ADD2BUFFER  ;add it to printBuffer
00002890  41F9 00001427           1624              LEA     wordMSG, A0   ;load ".W " message
00002896  4EB9 00001102           1625              JSR     ADD2BUFFER  ;append to printBuffer
0000289C  4EB9 00002F4E           1626              JSR     EA          ;jump to EA code for decoding source EA and appending to printBuffer
000028A2                          1627             
000028A2  4E75                    1628              RTS              ;return to MAIN.X68
000028A4                          1629  
000028A4                          1630  decLSR:
000028A4  41F9 00001411           1631              LEA     lsrMSG, A0  ;load "LSR" message
000028AA  4EB9 00001102           1632              JSR     ADD2BUFFER  ;add it to printBuffer
000028B0  41F9 00001427           1633              LEA     wordMSG, A0   ;load ".W " message
000028B6  4EB9 00001102           1634              JSR     ADD2BUFFER  ;append to printBuffer
000028BC  4EB9 00002F4E           1635              JSR     EA          ;jump to EA code for decoding source EA and appending to printBuffer
000028C2                          1636  
000028C2  4E75                    1637              RTS              ;return to MAIN.X68
000028C4                          1638  
000028C4                          1639  
000028C4                          1640  
000028C4                          1641  
000028C4                          1642  decLSLreg:  *** Decode LSL with reg or immediate as shift count ***
000028C4  3803                    1643              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000028C6  103C 0008               1644              MOVE.B  #8, D0      ;shift count for D4
000028CA  E0AC                    1645              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding size
000028CC  C8BC 00000001           1646              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
000028D2                          1647  
000028D2  B83C 0001               1648              CMP.B   #1, D4      ;is it rotate left?
000028D6  6600 009E               1649              BNE     decLSRreg    ;if no, skip to LSR
000028DA                          1650              
000028DA  41F9 0000140B           1651              LEA     lslMSG, A0  ;load "LSL" message
000028E0  4EB9 00001102           1652              JSR     ADD2BUFFER  ;add it to printBuffer
000028E6  4EB9 00002DD8           1653              JSR     GET_SIZE    ;get and load the size into printBuffer (.b, .w, .l)
000028EC                          1654              
000028EC  3803                    1655              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000028EE  103C 0005               1656              MOVE.B  #5, D0      ;shift count for D4
000028F2  E0AC                    1657              LSR.L   D0, D4      ;shift bit 5 to the far right to isolate for decoding shift count source
000028F4  C8BC 00000001           1658              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
000028FA                          1659  
000028FA  B83C 0001               1660              CMP.B   #1, D4      ;is it data reg as shift count source?
000028FE  6600 001C               1661              BNE     lsl_im    ;if no, skip to immediate shift count
00002902                          1662              
00002902  4EB9 00002BBC           1663              JSR     DECODE_DN   ;get data register as source and append to printBuffer
00002908  41F9 000012E9           1664              LEA     comma, A0   ;load a comma ", "
0000290E  4EB9 00001102           1665              JSR     ADD2BUFFER  ;append to printBuffer
00002914  4EB9 00002C72           1666              JSR     V2DECODE_DN   ;get data register as destination opperand and append to printBuffer
0000291A  4E75                    1667              RTS                 ;return to MAIN.X68
0000291C                          1668  
0000291C                          1669  
0000291C                          1670  lsl_im              *find immediate shift number  
0000291C  41F9 000012EC           1671              LEA     hashtag, A0 ;load "#" for immidiate
00002922  4EB9 00001102           1672              JSR     ADD2BUFFER  ;append to printBuffer
00002928  41F9 000012EE           1673              LEA     hexSign, A0 ;load  "$" for hex
0000292E  4EB9 00001102           1674              JSR     ADD2BUFFER  ;append to printBuffer
00002934                          1675     
00002934  3803                    1676              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002936  103C 0009               1677              MOVE.B  #9, D0      ;shift count for D4
0000293A  E0AC                    1678              LSR.L   D0, D4      ;shift bits 11-9 to the far right to isolate for decoding shift count (1-8)
0000293C  C8BC 00000007           1679              AND.L   #$7, D4      ;mask uneeded bits/set to zeros
00002942                          1680             
00002942  B83C 0000               1681              CMP.B   #0, D4       ;if it's zero, it needs to be adjusted to 8 first
00002946  6600 0004               1682              BNE     lsl_hex_conv
0000294A  5004                    1683              ADDI.B  #8, D4       ;change to 8, then continue with hex conversion
0000294C                          1684  lsl_hex_conv            
0000294C  103C 0008               1685              MOVE.B  #8,D0         ;load length of hex value
00002950  4EB9 0000110C           1686              JSR     HexToAscii    ;convert num in D4 to ascii, puts in hex2ascBuffer
00002956  41F9 000012DE           1687              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
0000295C  4EB9 00001102           1688              JSR     ADD2BUFFER      ;add immediate value to buffer
00002962  41F9 000012E9           1689              LEA     comma, A0   ;load a comma ", "
00002968  4EB9 00001102           1690              JSR     ADD2BUFFER  ;append to printBuffer
0000296E  4EB9 00002C72           1691              JSR     V2DECODE_DN     ;get data register as destination opperand and append to printBuffer
00002974  4E75                    1692              RTS                 ;return to MAIN.X68
00002976                          1693            
00002976                          1694  
00002976                          1695  
00002976                          1696  
00002976                          1697  decLSRreg:  *** Decode LSR with reg or immediate as shift count ***
00002976  41F9 00001411           1698              LEA     lsrMSG, A0  ;load "LSR" message
0000297C  4EB9 00001102           1699              JSR     ADD2BUFFER  ;add it to printBuffer
00002982  4EB9 00002DD8           1700              JSR     GET_SIZE    ;get and load the size into printBuffer (.b, .w, .l)
00002988                          1701  
00002988  3803                    1702              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
0000298A  103C 0005               1703              MOVE.B  #5, D0      ;shift count for D4
0000298E  E0AC                    1704              LSR.L   D0, D4      ;shift bit 5 to the far right to isolate for decoding shift count source
00002990  C8BC 00000001           1705              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
00002996                          1706  
00002996  B83C 0001               1707              CMP.B   #1, D4      ;is it data reg as shift count source?
0000299A  6600 001C               1708              BNE     lsr_im      ;if no, skip to immediate shift count
0000299E                          1709              
0000299E  4EB9 00002BBC           1710              JSR     DECODE_DN   ;get data register as source and append to printBuffer
000029A4  41F9 000012E9           1711              LEA     comma, A0   ;load a comma ", "
000029AA  4EB9 00001102           1712              JSR     ADD2BUFFER  ;append to printBuffer
000029B0  4EB9 00002C72           1713              JSR     V2DECODE_DN   ;get data register as destination opperand and append to printBuffer
000029B6  4E75                    1714              RTS                 ;return to MAIN.X68
000029B8                          1715  
000029B8                          1716  
000029B8                          1717  lsr_im              *find immediate shift number  
000029B8  41F9 000012EC           1718              LEA     hashtag, A0 ;load "#" for immidiate
000029BE  4EB9 00001102           1719              JSR     ADD2BUFFER  ;append to printBuffer
000029C4  41F9 000012EE           1720              LEA     hexSign, A0 ;load  "$" for hex
000029CA  4EB9 00001102           1721              JSR     ADD2BUFFER  ;append to printBuffer
000029D0                          1722     
000029D0  3803                    1723              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
000029D2  103C 0009               1724              MOVE.B  #9, D0      ;shift count for D4
000029D6  E0AC                    1725              LSR.L   D0, D4      ;shift bits 11-9 to the far right to isolate for decoding shift count (1-8)
000029D8  C8BC 00000007           1726              AND.L   #$7, D4      ;mask uneeded bits/set to zeros
000029DE                          1727             
000029DE  B83C 0000               1728              CMP.B   #0, D4       ;if it's zero, it needs to be adjusted to 8 first
000029E2  6600 0004               1729              BNE     lsr_hex_conv
000029E6                          1730              
000029E6  5004                    1731              ADDI.B  #8, D4       ;change to 8, then continue with hex conversion
000029E8                          1732  lsr_hex_conv            
000029E8  103C 0008               1733              MOVE.B  #8,D0         ;load length of hex value
000029EC  4EB9 0000110C           1734              JSR     HexToAscii    ;convert num in D4 to ascii, puts in hex2ascBuffer
000029F2  41F9 000012DE           1735              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
000029F8  4EB9 00001102           1736              JSR     ADD2BUFFER      ;add immediate value to buffer
000029FE  41F9 000012E9           1737              LEA     comma, A0   ;load a comma ", "
00002A04  4EB9 00001102           1738              JSR     ADD2BUFFER  ;append to printBuffer
00002A0A  4EB9 00002C72           1739              JSR     V2DECODE_DN     ;get data register as destination opperand and append to printBuffer
00002A10  4E75                    1740              RTS                 ;return to MAIN.X68
00002A12                          1741  
00002A12                          1742  
00002A12                          1743  
00002A12                          1744  
00002A12                          1745  
00002A12                          1746  
00002A12                          1747  decROL:
00002A12  3803                    1748              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002A14  103C 0008               1749              MOVE.B  #8, D0      ;shift count for D4
00002A18  E0AC                    1750              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding size
00002A1A  C8BC 00000001           1751              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
00002A20                          1752  
00002A20  B83C 0001               1753              CMP.B   #1, D4      ;is it rotate left?
00002A24  6600 0022               1754              BNE     decROR       ;if no, skip to ROR
00002A28                          1755              
00002A28  41F9 00001417           1756              LEA     rolMSG, A0  ;load "ROL" message
00002A2E  4EB9 00001102           1757              JSR     ADD2BUFFER  ;add it to printBuffer
00002A34  41F9 00001427           1758              LEA     wordMSG, A0   ;load ".W " message
00002A3A  4EB9 00001102           1759              JSR     ADD2BUFFER  ;append to printBuffer
00002A40  4EB9 00002F4E           1760              JSR     EA          ;jump to EA code for decoding source EA and appending to printBuffer
00002A46  4E75                    1761              RTS              ;return to MAIN.X68
00002A48                          1762              
00002A48                          1763  decROR:
00002A48  41F9 0000141D           1764              LEA     rorMSG, A0  ;load "ROR" message
00002A4E  4EB9 00001102           1765              JSR     ADD2BUFFER  ;add it to printBuffer
00002A54  41F9 00001427           1766              LEA     wordMSG, A0   ;load ".W " message
00002A5A  4EB9 00001102           1767              JSR     ADD2BUFFER  ;append to printBuffer
00002A60  4EB9 00002F4E           1768              JSR     EA          ;jump to EA code for decoding source EA and appending to printBuffer
00002A66  4E75                    1769              RTS              ;return to MAIN.X68
00002A68                          1770  
00002A68                          1771  
00002A68                          1772  
00002A68                          1773  decROLreg:  *** Decode ROL with reg or immediate as shift count ***
00002A68  3803                    1774              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002A6A  103C 0008               1775              MOVE.B  #8, D0      ;shift count for D4
00002A6E  E0AC                    1776              LSR.L   D0, D4      ;shift bit 8 to the far right to isolate for decoding size
00002A70  C8BC 00000001           1777              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
00002A76                          1778  
00002A76  B83C 0001               1779              CMP.B   #1, D4      ;is it rotate left?
00002A7A  6600 009E               1780              BNE     decRORreg    ;if no, skip to ROR
00002A7E                          1781              
00002A7E  41F9 00001417           1782              LEA     rolMSG, A0  ;load "ROL" message
00002A84  4EB9 00001102           1783              JSR     ADD2BUFFER  ;add it to printBuffer
00002A8A  4EB9 00002DD8           1784              JSR     GET_SIZE    ;get and load the size into printBuffer (.b, .w, .l)
00002A90                          1785              
00002A90  3803                    1786              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002A92  103C 0005               1787              MOVE.B  #5, D0      ;shift count for D4
00002A96  E0AC                    1788              LSR.L   D0, D4      ;shift bit 5 to the far right to isolate for decoding shift count source
00002A98  C8BC 00000001           1789              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
00002A9E                          1790  
00002A9E  B83C 0001               1791              CMP.B   #1, D4      ;is it data reg as shift count source?
00002AA2  6600 001C               1792              BNE     rol_im    ;if no, skip to immediate shift count
00002AA6                          1793              
00002AA6  4EB9 00002BBC           1794              JSR     DECODE_DN   ;get data register as source and append to printBuffer
00002AAC  41F9 000012E9           1795              LEA     comma, A0   ;load a comma ", "
00002AB2  4EB9 00001102           1796              JSR     ADD2BUFFER  ;append to printBuffer
00002AB8  4EB9 00002C72           1797              JSR     V2DECODE_DN   ;get data register as destination opperand and append to printBuffer
00002ABE  4E75                    1798              RTS                 ;return to MAIN.X68
00002AC0                          1799  
00002AC0                          1800  
00002AC0                          1801  rol_im              *find immediate shift number 
00002AC0  41F9 000012EC           1802              LEA     hashtag, A0 ;load "#" for immidiate
00002AC6  4EB9 00001102           1803              JSR     ADD2BUFFER  ;append to printBuffer
00002ACC  41F9 000012EE           1804              LEA     hexSign, A0 ;load  "$" for hex
00002AD2  4EB9 00001102           1805              JSR     ADD2BUFFER  ;append to printBuffer
00002AD8                          1806      
00002AD8  3803                    1807              MOVE.W  D3, D4       ;make a temp copy of opword in D4 for manipulation
00002ADA  103C 0009               1808              MOVE.B  #9, D0       ;shift count for D4
00002ADE  E0AC                    1809              LSR.L   D0, D4       ;shift bits 11-9 to the far right to isolate for decoding shift count (1-8)
00002AE0  C8BC 00000007           1810              AND.L   #$7, D4      ;mask uneeded bits/set to zeros
00002AE6                          1811             
00002AE6  B83C 0000               1812              CMP.B   #0, D4       ;if it's zero, it needs to be adjusted to 8 first
00002AEA  6600 0004               1813              BNE     rol_hex_conv
00002AEE  5004                    1814              ADDI.B  #8, D4       ;change to 8, then continue with hex conversion
00002AF0                          1815  rol_hex_conv            
00002AF0  103C 0008               1816              MOVE.B  #8,D0           ;load length of hex value
00002AF4  4EB9 0000110C           1817              JSR     HexToAscii      ;convert num in D4 to ascii, puts in hex2ascBuffer
00002AFA  41F9 000012DE           1818              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
00002B00  4EB9 00001102           1819              JSR     ADD2BUFFER      ;add immediate value to buffer
00002B06  41F9 000012E9           1820              LEA     comma, A0       ;load a comma ", "
00002B0C  4EB9 00001102           1821              JSR     ADD2BUFFER      ;append to printBuffer
00002B12  4EB9 00002C72           1822              JSR     V2DECODE_DN     ;get data register as destination opperand and append to printBuffer
00002B18  4E75                    1823              RTS                 ;return to MAIN.X68
00002B1A                          1824  
00002B1A                          1825  
00002B1A                          1826  
00002B1A                          1827  decRORreg:  *** Decode ROR with reg or immediate as shift count ***
00002B1A  41F9 0000141D           1828              LEA     rorMSG, A0  ;load "ROR" message
00002B20  4EB9 00001102           1829              JSR     ADD2BUFFER  ;add it to printBuffer
00002B26  4EB9 00002DD8           1830              JSR     GET_SIZE    ;get and load the size into printBuffer (.b, .w, .l)
00002B2C                          1831  
00002B2C  3803                    1832              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002B2E  103C 0005               1833              MOVE.B  #5, D0      ;shift count for D4
00002B32  E0AC                    1834              LSR.L   D0, D4      ;shift bit 5 to the far right to isolate for decoding shift count source
00002B34  C8BC 00000001           1835              AND.L   #$1, D4      ;mask uneeded bits/set to zeros
00002B3A                          1836  
00002B3A  B83C 0001               1837              CMP.B   #1, D4      ;is it data reg as shift count source?
00002B3E  6600 001C               1838              BNE     ror_im      ;if no, skip to immediate shift count
00002B42                          1839              
00002B42  4EB9 00002BBC           1840              JSR     DECODE_DN   ;get data register as source and append to printBuffer
00002B48  41F9 000012E9           1841              LEA     comma, A0   ;load a comma ", "
00002B4E  4EB9 00001102           1842              JSR     ADD2BUFFER  ;append to printBuffer
00002B54  4EB9 00002C72           1843              JSR     V2DECODE_DN   ;get data register as destination opperand and append to printBuffer
00002B5A  4E75                    1844              RTS                 ;return to MAIN.X68
00002B5C                          1845  
00002B5C                          1846  
00002B5C                          1847  ror_im              *find immediate shift number 
00002B5C  41F9 000012EC           1848              LEA     hashtag, A0 ;load "#" for immidiate
00002B62  4EB9 00001102           1849              JSR     ADD2BUFFER  ;append to printBuffer
00002B68  41F9 000012EE           1850              LEA     hexSign, A0 ;load  "$" for hex
00002B6E  4EB9 00001102           1851              JSR     ADD2BUFFER  ;append to printBuffer
00002B74                          1852                
00002B74  3803                    1853              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002B76  103C 0009               1854              MOVE.B  #9, D0      ;shift count for D4
00002B7A  E0AC                    1855              LSR.L   D0, D4      ;shift bits 11-9 to the far right to isolate for decoding shift count (1-8)
00002B7C  C8BC 00000007           1856              AND.L   #$7, D4      ;mask uneeded bits/set to zeros
00002B82                          1857             
00002B82  B83C 0000               1858              CMP.B   #0, D4       ;if it's zero, it needs to be adjusted to 8 first
00002B86  6600 0004               1859              BNE     ror_hex_conv
00002B8A                          1860              
00002B8A  5004                    1861              ADDI.B  #8, D4       ;change to 8, then continue with hex conversion
00002B8C                          1862  ror_hex_conv            
00002B8C  103C 0008               1863              MOVE.B  #8,D0         ;load length of hex value
00002B90  4EB9 0000110C           1864              JSR     HexToAscii    ;convert num in D4 to ascii, puts in hex2ascBuffer
00002B96  41F9 000012DE           1865              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
00002B9C  4EB9 00001102           1866              JSR     ADD2BUFFER      ;add immediate value to buffer
00002BA2  41F9 000012E9           1867              LEA     comma, A0       ;load a comma ", "
00002BA8  4EB9 00001102           1868              JSR     ADD2BUFFER      ;append to printBuffer
00002BAE  4EB9 00002C72           1869              JSR     V2DECODE_DN     ;get data register as destination opperand and append to printBuffer
00002BB4  4E75                    1870              RTS                 ;return to MAIN.X68
00002BB6                          1871  
00002BB6                          1872  
00002BB6                          1873  
00002BB6                          1874  
00002BB6                          1875  
00002BB6                          1876              
00002BB6                          1877              
00002BB6                          1878  
00002BB6                          1879  BADFLAG:    
00002BB6  1A3C 0000               1880              MOVE.B #0,D5  ;set flag to bad, can't decode
00002BBA  4E75                    1881              RTS     ;return to caller in Main.X68 to print address and word value
00002BBC                          1882  
00002BBC                          1883  
00002BBC                          1884  
00002BBC                          1885  
00002BBC                          1886  
00002BBC                          1887  
00002BBC                          1888  
00002BBC                          1889        
00002BBC                          1890        
00002BBC                          1891  
00002BBC                          1892  DECODE_DN:  
00002BBC  3803                    1893              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002BBE  103C 0009               1894              MOVE.B  #9, D0      ;shift count for D4
00002BC2  E0AC                    1895              LSR.L   D0, D4      ;shift bits 11-9 to far right to isolate for data register decode
00002BC4  C8BC 00000007           1896              AND.L   #7, D4      ;mask uneeded bits/set to zeros
00002BCA                          1897  D_zero:
00002BCA  B83C 0000               1898              CMP.B   #0, D4       ;is it D0?
00002BCE  6600 0010               1899              BNE     D_one       ;if not try D1
00002BD2  41F9 0000142F           1900              LEA     d0MSG, A0    ;else load D0 message
00002BD8  4EB9 00001102           1901              JSR     ADD2BUFFER  ;add message to printBuffer
00002BDE  4E75                    1902              RTS
00002BE0                          1903  D_one: 
00002BE0  B83C 0001               1904              CMP.B   #1, D4       ;is it D1?
00002BE4  6600 0010               1905              BNE     D_two       ;if not try D2
00002BE8  41F9 00001432           1906              LEA     d1MSG, A0    ;else load D1 message
00002BEE  4EB9 00001102           1907              JSR     ADD2BUFFER  ;add message to printBuffer
00002BF4  4E75                    1908              RTS
00002BF6                          1909  
00002BF6                          1910  D_two:  
00002BF6  B83C 0002               1911              CMP.B   #2, D4       ;is it D2?
00002BFA  6600 0010               1912              BNE     D_three     ;if not try D3
00002BFE  41F9 00001435           1913              LEA     d2MSG, A0    ;else load D2 message
00002C04  4EB9 00001102           1914              JSR     ADD2BUFFER  ;add message to printBuffer
00002C0A  4E75                    1915              RTS
00002C0C                          1916  
00002C0C                          1917  D_three:
00002C0C  B83C 0003               1918              CMP.B   #3, D4       ;is it D3?
00002C10  6600 0010               1919              BNE     D_four      ;if not try D4
00002C14  41F9 00001438           1920              LEA     d3MSG, A0    ;else load D3 message
00002C1A  4EB9 00001102           1921              JSR     ADD2BUFFER  ;add message to printBuffer
00002C20  4E75                    1922              RTS
00002C22                          1923  
00002C22                          1924  D_four: 
00002C22  B83C 0004               1925              CMP.B   #4, D4       ;is it D4?
00002C26  6600 0010               1926              BNE     D_five      ;if not try D5
00002C2A  41F9 0000143B           1927              LEA     d4MSG, A0    ;else load D4 message
00002C30  4EB9 00001102           1928              JSR     ADD2BUFFER  ;add message to printBuffer
00002C36  4E75                    1929              RTS
00002C38                          1930  
00002C38                          1931  D_five:
00002C38  B83C 0005               1932              CMP.B   #5, D4       ;is it D5?
00002C3C  6600 0010               1933              BNE     D_six       ;if not try D6
00002C40  41F9 0000143E           1934              LEA     d5MSG, A0    ;else load D5 message
00002C46  4EB9 00001102           1935              JSR     ADD2BUFFER  ;add message to printBuffer
00002C4C  4E75                    1936              RTS
00002C4E                          1937  
00002C4E                          1938  D_six       
00002C4E  B83C 0006               1939              CMP.B   #6, D4       ;is it D6?
00002C52  6600 0010               1940              BNE     D_seven     ;if not, try D7
00002C56  41F9 00001441           1941              LEA     d6MSG, A0    ;else load D6 message
00002C5C  4EB9 00001102           1942              JSR     ADD2BUFFER  ;add message to printBuffer
00002C62  4E75                    1943              RTS
00002C64                          1944              
00002C64                          1945  D_seven:
00002C64  41F9 00001444           1946              LEA     d7MSG, A0    ;is has to be D7 then. Load D7 message
00002C6A  4EB9 00001102           1947              JSR     ADD2BUFFER  ;add message to printBuffer
00002C70  4E75                    1948              RTS
00002C72                          1949  
00002C72                          1950  
00002C72                          1951  
00002C72                          1952  V2DECODE_DN:  
00002C72  3803                    1953              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002C74  C8BC 00000007           1954              AND.L   #7, D4      ;mask uneeded bits/set to zeros
00002C7A                          1955  V2D_zero:
00002C7A  B83C 0000               1956              CMP.B   #0, D4       ;is it D0?
00002C7E  6600 0010               1957              BNE     V2D_one       ;if not try D1
00002C82  41F9 0000142F           1958              LEA     d0MSG, A0    ;else load D0 message
00002C88  4EB9 00001102           1959              JSR     ADD2BUFFER  ;add message to printBuffer
00002C8E  4E75                    1960              RTS
00002C90                          1961  V2D_one: 
00002C90  B83C 0001               1962              CMP.B   #1, D4       ;is it D1?
00002C94  6600 0010               1963              BNE     V2D_two       ;if not try D2
00002C98  41F9 00001432           1964              LEA     d1MSG, A0    ;else load D1 message
00002C9E  4EB9 00001102           1965              JSR     ADD2BUFFER  ;add message to printBuffer
00002CA4  4E75                    1966              RTS
00002CA6                          1967  
00002CA6                          1968  V2D_two:  
00002CA6  B83C 0002               1969              CMP.B   #2, D4       ;is it D2?
00002CAA  6600 0010               1970              BNE     V2D_three     ;if not try D3
00002CAE  41F9 00001435           1971              LEA     d2MSG, A0    ;else load D2 message
00002CB4  4EB9 00001102           1972              JSR     ADD2BUFFER  ;add message to printBuffer
00002CBA  4E75                    1973              RTS
00002CBC                          1974  
00002CBC                          1975  V2D_three:
00002CBC  B83C 0003               1976              CMP.B   #3, D4       ;is it D3?
00002CC0  6600 0010               1977              BNE     V2D_four      ;if not try D4
00002CC4  41F9 00001438           1978              LEA     d3MSG, A0    ;else load D3 message
00002CCA  4EB9 00001102           1979              JSR     ADD2BUFFER  ;add message to printBuffer
00002CD0  4E75                    1980              RTS
00002CD2                          1981  
00002CD2                          1982  V2D_four: 
00002CD2  B83C 0004               1983              CMP.B   #4, D4       ;is it D4?
00002CD6  6600 0010               1984              BNE     V2D_five      ;if not try D5
00002CDA  41F9 0000143B           1985              LEA     d4MSG, A0    ;else load D4 message
00002CE0  4EB9 00001102           1986              JSR     ADD2BUFFER  ;add message to printBuffer
00002CE6  4E75                    1987              RTS
00002CE8                          1988  
00002CE8                          1989  V2D_five:
00002CE8  B83C 0005               1990              CMP.B   #5, D4       ;is it D5?
00002CEC  6600 0010               1991              BNE     V2D_six       ;if not try D6
00002CF0  41F9 0000143E           1992              LEA     d5MSG, A0    ;else load D5 message
00002CF6  4EB9 00001102           1993              JSR     ADD2BUFFER  ;add message to printBuffer
00002CFC  4E75                    1994              RTS
00002CFE                          1995  
00002CFE                          1996  V2D_six       
00002CFE  B83C 0006               1997              CMP.B   #6, D4       ;is it D6?
00002D02  6600 0010               1998              BNE     V2D_seven     ;if not, try D7
00002D06  41F9 00001441           1999              LEA     d6MSG, A0    ;else load D6 message
00002D0C  4EB9 00001102           2000              JSR     ADD2BUFFER  ;add message to printBuffer
00002D12  4E75                    2001              RTS
00002D14                          2002              
00002D14                          2003  V2D_seven:
00002D14  41F9 00001444           2004              LEA     d7MSG, A0    ;is has to be D7 then. Load D7 message
00002D1A  4EB9 00001102           2005              JSR     ADD2BUFFER  ;add message to printBuffer
00002D20  4E75                    2006              RTS
00002D22                          2007  
00002D22                          2008       
00002D22                          2009  
00002D22                          2010  DECODE_AN:  
00002D22  3803                    2011              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002D24  103C 0009               2012              MOVE.B  #9, D0      ;shift count for D4
00002D28  E0AC                    2013              LSR.L   D0, D4      ;shift bits 11-9 to far right to isolate for address register decode
00002D2A  C8BC 00000007           2014              AND.L   #7, D4      ;mask uneeded bits/set to zeros
00002D30                          2015  
00002D30                          2016           
00002D30  B83C 0000               2017              CMP.B   #0,D4       ;is it A0?
00002D34  6600 0010               2018              BNE     A_one       ;if not, try A1
00002D38  41F9 00001447           2019              LEA     ar0MSG,A0    ;else load A0 message
00002D3E  4EB9 00001102           2020              JSR     ADD2BUFFER  ;add message to printBuffer
00002D44  4E75                    2021              RTS
00002D46                          2022  A_one: 
00002D46  B83C 0001               2023              CMP.B   #1,D4       ;is it A1?
00002D4A  6600 0010               2024              BNE     A_two       ;if not, try A2
00002D4E  41F9 0000144A           2025              LEA     ar1MSG,A0    ;else load A1 message
00002D54  4EB9 00001102           2026              JSR     ADD2BUFFER  ;add message to printBuffer
00002D5A  4E75                    2027              RTS
00002D5C                          2028  
00002D5C                          2029  A_two:  
00002D5C  B83C 0002               2030              CMP.B   #2,D4       ;is it A2?
00002D60  6600 0010               2031              BNE     A_three     ;if not, try A3
00002D64  41F9 0000144D           2032              LEA     ar2MSG,A0    ;else load A2 message
00002D6A  4EB9 00001102           2033              JSR     ADD2BUFFER  ;add message to printBuffer
00002D70  4E75                    2034              RTS
00002D72                          2035  
00002D72                          2036  A_three:
00002D72  B83C 0003               2037              CMP.B   #3,D4       ;is it A3?
00002D76  6600 0010               2038              BNE     A_four      ;if not, try A4
00002D7A  41F9 00001450           2039              LEA     ar3MSG,A0    ;else load A3 message
00002D80  4EB9 00001102           2040              JSR     ADD2BUFFER  ;add message to printBuffer
00002D86  4E75                    2041              RTS
00002D88                          2042  
00002D88                          2043  A_four: 
00002D88  B83C 0004               2044              CMP.B   #4,D4       ;is it A4?
00002D8C  6600 0010               2045              BNE     A_five      ;if not, try A5
00002D90  41F9 00001453           2046              LEA     ar4MSG,A0    ;else load A4 message
00002D96  4EB9 00001102           2047              JSR     ADD2BUFFER  ;add message to printBuffer
00002D9C  4E75                    2048              RTS
00002D9E                          2049  
00002D9E                          2050  A_five:
00002D9E  B83C 0005               2051              CMP.B   #5,D4       ;is it A5?
00002DA2  6600 0010               2052              BNE     A_six       ;if not, try A6
00002DA6  41F9 00001456           2053              LEA     ar5MSG,A0    ;else load A5 message
00002DAC  4EB9 00001102           2054              JSR     ADD2BUFFER  ;add message to printBuffer
00002DB2  4E75                    2055              RTS
00002DB4                          2056  
00002DB4                          2057  A_six       
00002DB4  B83C 0006               2058              CMP.B   #6,D4       ;is it A6?
00002DB8  6600 0010               2059              BNE     A_seven     ;if not, try A7
00002DBC  41F9 00001459           2060              LEA     ar6MSG,A0    ;else load A6 message
00002DC2  4EB9 00001102           2061              JSR     ADD2BUFFER  ;add message to printBuffer
00002DC8  4E75                    2062              RTS
00002DCA                          2063  
00002DCA                          2064  A_seven:
00002DCA  41F9 0000145C           2065              LEA     ar7MSG,A0    ;is has to be A7 then. Load A7 message
00002DD0  4EB9 00001102           2066              JSR     ADD2BUFFER  ;add message to printBuffer
00002DD6  4E75                    2067              RTS
00002DD8                          2068              
00002DD8                          2069  
00002DD8                          2070  GET_SIZE:            
00002DD8  3803                    2071              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002DDA  103C 0006               2072              MOVE.B  #6, D0      ;shift count for D4
00002DDE  E0AC                    2073              LSR.L   D0, D4      ;shift bits 7-6 to the far right to isolate for decoding size
00002DE0  C8BC 00000003           2074              AND.L   #3, D4      ;mask uneeded bits/set to zeros
00002DE6                          2075              
00002DE6  B83C 0000               2076              CMP.B   #0, D4      ;is it a byte?
00002DEA  6700 0016               2077              BEQ     sByte      
00002DEE  B83C 0001               2078              CMP.B   #1, D4      ;is it a word?
00002DF2  6700 0020               2079              BEQ     sWord
00002DF6  B83C 0002               2080              CMP.B   #2, D4      ;is it a long?
00002DFA  6700 002A               2081              BEQ     sLong
00002DFE  4EF8 2BB6               2082              JMP     BADFLAG     ;if not these, can't decode
00002E02                          2083  sByte:
00002E02  41F9 00001423           2084              LEA     byteMSG, A0 ;load ".B " message
00002E08  4EB9 00001102           2085              JSR     ADD2BUFFER  ;append to printBuffer
00002E0E  1C3C 0008               2086              MOVE.B  #8, D6     ;set size for EA decodeing
00002E12  4E75                    2087              RTS         
00002E14                          2088  sWord:
00002E14  41F9 00001427           2089              LEA     wordMSG, A0 ;load ".B " message
00002E1A  4EB9 00001102           2090              JSR     ADD2BUFFER  ;append to printBuffer
00002E20  1C3C 0010               2091              MOVE.B  #16, D6     ;set size for EA decodeing
00002E24  4E75                    2092              RTS     
00002E26                          2093  sLong:            
00002E26  41F9 0000142B           2094              LEA     longMSG, A0 ;load ".B " message
00002E2C  4EB9 00001102           2095              JSR     ADD2BUFFER  ;append to printBuffer
00002E32  1C3C 0020               2096              MOVE.B  #32, D6     ;set size for EA decodeing 
00002E36  4E75                    2097              RTS        
00002E38                          2098  
00002E38                          2099  
00002E38                          2100  
00002E38                          2101  
00002E38                          2102  GET_IM_SIZE:
00002E38  3803                    2103              MOVE.W  D3, D4      ;make a temp copy of opword in D4 for manipulation
00002E3A  103C 0006               2104              MOVE.B  #6, D0      ;shift count for D4
00002E3E  E0AC                    2105              LSR.L   D0, D4      ;shift bits 7-6 to the far right to isolate for decoding size
00002E40  C8BC 00000003           2106              AND.L   #3, D4      ;mask uneeded bits/set to zeros
00002E46  B83C 0000               2107              CMP.B   #0, D4      ;is it a byte?
00002E4A  6600 0052               2108              BNE     size_w      ;if no, skip to next comparison
00002E4E                          2109              
00002E4E                          2110  size_b:
00002E4E  41F9 00001423           2111              LEA     byteMSG, A0   ;load message ".B "
00002E54  4EB9 00001102           2112              JSR     ADD2BUFFER    ;add message to printBuffer            
00002E5A  41F9 000012EC           2113              LEA     hashtag, A0   ;load message "#"
00002E60  4EB9 00001102           2114              JSR     ADD2BUFFER    ;add message to printBuffer           
00002E66  41F9 000012EE           2115              LEA     hexSign, A0   ;load message "$"
00002E6C  4EB9 00001102           2116              JSR     ADD2BUFFER    ;add message to printBuffer
00002E72                          2117  
00002E72  4284                    2118              CLR.L   D4            ;clear register  
00002E74  4280                    2119              CLR.L   D0            ;clear register
00002E76  384B                    2120              MOVE.W  A3, A4        ;update address pointer incase opcode still can't be decoded at some point
00002E78  381B                    2121              MOVE.W  (A3)+, D4     ;grab the immediate data from the word after the opcode
00002E7A  103C 0008               2122              MOVE.B  #8,D0         ;load length of hex value
00002E7E  4EB9 0000110C           2123              JSR     HexToAscii    ;convert to ascii, puts in hex2ascBuffer
00002E84  41F9 000012DE           2124              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
00002E8A  4EB9 00001102           2125              JSR     ADD2BUFFER      ;add immediate value to buffer
00002E90                          2126              
00002E90  41F9 000012E9           2127              LEA     comma, A0    ;load message ", " 
00002E96  4EB9 00001102           2128              JSR     ADD2BUFFER   ;add to buffer
00002E9C  4E75                    2129              RTS             
00002E9E                          2130  
00002E9E                          2131  size_w:
00002E9E  B83C 0001               2132              CMP.B   #1, D4      ;is it a word?
00002EA2  6600 0052               2133              BNE     size_l   ;if no, skip to next comparison
00002EA6                          2134              
00002EA6  41F9 00001427           2135              LEA     wordMSG, A0   ;load message ".W "
00002EAC  4EB9 00001102           2136              JSR     ADD2BUFFER    ;add message to printBuffer          
00002EB2  41F9 000012EC           2137              LEA     hashtag, A0   ;load message "#"
00002EB8  4EB9 00001102           2138              JSR     ADD2BUFFER    ;add message to printBuffer           
00002EBE  41F9 000012EE           2139              LEA     hexSign, A0   ;load message "$"
00002EC4  4EB9 00001102           2140              JSR     ADD2BUFFER    ;add message to printBuffer
00002ECA                          2141              
00002ECA  4284                    2142              CLR.L   D4            ;clear register  
00002ECC  4280                    2143              CLR.L   D0            ;clear register
00002ECE  384B                    2144              MOVE.W  A3, A4        ;update address pointer incase opcode still can't be decoded at some point
00002ED0  381B                    2145              MOVE.W  (A3)+, D4     ;grab the immediate data from the word after the opcode
00002ED2  103C 0010               2146              MOVE.B  #16, D0        ;load length of hex value
00002ED6  4EB9 0000110C           2147              JSR     HexToAscii    ;convert to ascii, puts in hex2ascBuffer
00002EDC  41F9 000012DE           2148              LEA     hex2ascBuffer, A0  ;load ascii buffer  for printing
00002EE2  4EB9 00001102           2149              JSR     ADD2BUFFER      ;add immediate value to buffer
00002EE8                          2150              
00002EE8  41F9 000012E9           2151              LEA     comma, A0    ;load message ", " 
00002EEE  4EB9 00001102           2152              JSR     ADD2BUFFER   ;add to buffer
00002EF4  4E75                    2153              RTS         
00002EF6                          2154  
00002EF6                          2155  
00002EF6                          2156  size_l:            
00002EF6  B83C 0002               2157              CMP.B   #2, D4      ;is it a long?
00002EFA  6600 FCBA               2158              BNE     BADFLAG    ;if no, can't be decoded   
00002EFE                          2159           
00002EFE  41F9 0000142B           2160              LEA     longMSG, A0   ;load message ".L "
00002F04  4EB9 00001102           2161              JSR     ADD2BUFFER    ;add message to printBuffer                        
00002F0A  41F9 000012EC           2162              LEA     hashtag, A0   ;load message "#"
00002F10  4EB9 00001102           2163              JSR     ADD2BUFFER    ;add message to printBuffer            
00002F16  41F9 000012EE           2164              LEA     hexSign, A0   ;load message "$"
00002F1C  4EB9 00001102           2165              JSR     ADD2BUFFER    ;add message to printBuffer
00002F22                          2166              
00002F22  4284                    2167              CLR.L   D4            ;clear register  
00002F24  4280                    2168              CLR.L   D0            ;clear register
00002F26  384B                    2169              MOVE.W  A3, A4        ;update address pointer incase opcode still can't be decoded at some point
00002F28  281B                    2170              MOVE.L  (A3)+, D4     ;grab the immediate data from the long after the opcode
00002F2A  103C 0020               2171              MOVE.B  #32,D0        ;load length of hex value
00002F2E  4EB9 0000110C           2172              JSR     HexToAscii    ;convert to ascii, puts in hex2ascBuffer
00002F34  41F9 000012DE           2173              LEA     hex2ascBuffer, A0  ;load ascii buffer  for printing
00002F3A  4EB9 00001102           2174              JSR     ADD2BUFFER      ;add immediate value to buffer
00002F40                          2175              
00002F40  41F9 000012E9           2176              LEA     comma, A0    ;load message ", " 
00002F46  4EB9 00001102           2177              JSR     ADD2BUFFER   ;add to buffer
00002F4C  4E75                    2178              RTS
00002F4E                          2179      
00002F4E                          2180      
00002F4E                          2181      
00002F4E                          2182      
00002F4E                          2183      
00002F4E                          2184      
00002F4E                          2185      
00002F4E                          2186      
00002F4E                          2187      
00002F4E                          2188      
00002F4E                          2189      
00002F4E                          2190      
00002F4E                          2191      
00002F4E                          2192      
00002F4E                          2193      
00002F4E                          2194      
00002F4E                          2195      
00002F4E                          2196      
00002F4E                          2197      
00002F4E                          2198      
00002F4E                          2199      
00002F4E                          2200  
00002F4E                          2201  
00002F4E                          2202  
00002F4E                          2203  
00002F4E                          2204  -------------------- end include --------------------
00002F4E                          2205              INCLUDE 'Midori_Williams_EA.X68'
00002F4E                          2206  
00002F4E                          2207  
00002F4E                          2208  
00002F4E                          2209  EA:
00002F4E                          2210  
00002F4E  3803                    2211          MOVE.W  D3, D4      ;Copy of D3 to D4 for manipulation
00002F50  E64C                    2212          LSR.W   #3, D4      ;Shift data 3 times to the right
00002F52  0244 0007               2213          ANDI.W  #$0007, D4  ;Bit masking for 3 from the LSB
00002F56  143C 0001               2214          MOVE.B  #$1, D2     ;Set a flag for EA
00002F5A  4EB9 00002F76           2215          JSR     MODE
00002F60  4E75                    2216          RTS
00002F62                          2217  
00002F62                          2218  
00002F62                          2219  
00002F62                          2220  
00002F62                          2221  
00002F62                          2222  MOVE_EA:
00002F62  3803                    2223          MOVE.W  D3, D4      ;Copy data from D3 to D4
00002F64  EC4C                    2224          LSR.W   #6, D4      ;Shift data 6 times to the right
00002F66  0244 0007               2225          ANDI.W  #$0007,D4   ;Bit mask for 3 from the LSB
00002F6A  143C 0000               2226          MOVE.B  #$0, D2     ;Flag set to 0 indicating MOVE_EA
00002F6E  4EB9 00002F76           2227          JSR     MODE        
00002F74  4E75                    2228          RTS    
00002F76                          2229  
00002F76                          2230  
00002F76                          2231  MODE:
00002F76                          2232              
00002F76  B87C 0000               2233              CMP.W  #$00,D4      ;compare 0x00 to D4
00002F7A  6700 0058               2234              BEQ    DATAREG      ;if equal, branch to data register
00002F7E                          2235              
00002F7E  B87C 0001               2236              CMP.W  #$01,D4      ;compare 0x01 to D4
00002F82  6700 0116               2237              BEQ    ADDRREG      ;if equal, branch to address register
00002F86                          2238              
00002F86  B87C 0002               2239              CMP.W  #$02,D4      ;compare 0x02 to D4
00002F8A  6700 01D4               2240              BEQ    ADDRESS      ;if equal, branch to address   
00002F8E                          2241              
00002F8E  B87C 0003               2242              CMP.W  #$03,D4      ;compare 0x03 to D4
00002F92  6700 0292               2243              BEQ    ADDRPOST     ;if equal, branch to address with postincrement 
00002F96                          2244               
00002F96  B87C 0004               2245              CMP.W  #$04,D4      ;compare 0x04 to D4
00002F9A  6700 0350               2246              BEQ    ADDRPRE      ;if equal, branch to address with predecrement     
00002F9E                          2247              
00002F9E  B87C 0007               2248              CMP.W  #$07,D4      ;compare 0x07 to D4
00002FA2  6700 0008               2249              BEQ    ABSOLUTE     ;if equal, branch to Absolute/Immediate
00002FA6                          2250      
00002FA6  6600 FC0E               2251              BNE    BADFLAG      ;if it does not equal set flag
00002FAA                          2252              
00002FAA  4E75                    2253              RTS
00002FAC                          2254              
00002FAC                          2255  
00002FAC                          2256  ABSOLUTE:
00002FAC                          2257  
00002FAC  3803                    2258              MOVE.W D3, D4       ;Move another copy to D4
00002FAE  0244 0007               2259              ANDI.W #$0007, D4   ;Bit mask for address
00002FB2                          2260                          
00002FB2  B87C 0000               2261              CMP.W  #$00,D4      ;compare 0x00 to D4
00002FB6  6700 03FA               2262              BEQ    ABSSHORT     ;if equal, branch to absolute short
00002FBA                          2263              
00002FBA  B87C 0001               2264              CMP.W  #$01,D4      ;compare 0x01 to D4
00002FBE  6700 041C               2265              BEQ    ABSLONG      ;if equal, branch to absolute long
00002FC2                          2266              
00002FC2  B87C 0004               2267              CMP.W  #$04,D4      ;compare 0x04 to D4
00002FC6  6700 043E               2268              BEQ    IMMED        ;if equal, branch to immediate
00002FCA                          2269              
00002FCA  6600 FBEA               2270              BNE    BADFLAG      ;if it does not equal any values above, then branch to BADFLAG           
00002FCE                          2271  
00002FCE  4E75                    2272              RTS
00002FD0                          2273  
00002FD0                          2274  CANNOTDECODE:
00002FD0                          2275              
00002FD0  4EF8 2BB6               2276              JMP BADFLAG
00002FD4                          2277  
00002FD4                          2278  
00002FD4                          2279             
00002FD4                          2280  DATAREG:
00002FD4                          2281              
00002FD4  3803                    2282          MOVE.W  D3, D4      ;Move a copy of D3 into D4 for manipulation
00002FD6                          2283          
00002FD6  B43C 0001               2284          CMP.B   #$1, D2     ; Check if move flag set
00002FDA  6700 000C               2285          BEQ     Bitm_d      ; branch if equal to bit masking
00002FDE  103C 0009               2286          MOVE.B  #$9,D0      ; Move 9 into register D0
00002FE2  E06C                    2287          LSR.W   D0, D4      ; Shift right 9 times for move_ea
00002FE4  6000 0002               2288          BRA     Bitm_d      ; branch to bit masking
00002FE8                          2289          
00002FE8                          2290          
00002FE8                          2291          
00002FE8  0244 0007               2292  Bitm_d  ANDI.W  #$0007,D4   ;Bit mask 3 bits from LSB  
00002FEC  4242                    2293          CLR.W   D2          ;Clear the flag
00002FEE                          2294  Data0:
00002FEE  B83C 0000               2295          CMP.B   #$00,D4     ;If 0, place string 'D0' into print buffer
00002FF2  6600 0010               2296          BNE     Data1       
00002FF6  41F9 0000142F           2297          LEA     d0MSG,A0    
00002FFC  4EB9 00001102           2298          JSR     ADD2BUFFER
00003002  4E75                    2299          RTS
00003004                          2300  
00003004                          2301  Data1:  
00003004  B83C 0001               2302          CMP.B   #$1,D4      ;If 1, place string 'D1' into print buffer
00003008  6600 0010               2303          BNE     Data2       
0000300C  41F9 00001432           2304          LEA     d1MSG,A0    
00003012  4EB9 00001102           2305          JSR     ADD2BUFFER
00003018  4E75                    2306          RTS
0000301A                          2307          
0000301A                          2308  Data2:  
0000301A  B83C 0002               2309          CMP.B   #$2,D4      ;If 2, place string 'D2' into print buffer    
0000301E  6600 0010               2310          BNE     Data3       
00003022  41F9 00001435           2311          LEA     d2MSG,A0    
00003028  4EB9 00001102           2312          JSR     ADD2BUFFER
0000302E  4E75                    2313          RTS
00003030                          2314  
00003030                          2315  Data3:      
00003030  B83C 0003               2316          CMP.B   #$3,D4      ;If 3, place string 'D3' into print buffer 
00003034  6600 0010               2317          BNE     Data4
00003038  41F9 00001438           2318          LEA     d3MSG,A0
0000303E  4EB9 00001102           2319          JSR     ADD2BUFFER
00003044  4E75                    2320          RTS
00003046                          2321          
00003046                          2322  Data4:  
00003046  B83C 0004               2323          CMP.B   #$4,D4      ;If 4, place string 'D4' into print buffer 
0000304A  6600 0010               2324          BNE     Data5
0000304E  41F9 0000143B           2325          LEA     d4MSG,A0
00003054  4EB9 00001102           2326          JSR     ADD2BUFFER
0000305A  4E75                    2327          RTS
0000305C                          2328      
0000305C                          2329  Data5:  
0000305C  B83C 0005               2330          CMP.B   #$5,D4      ;If 5, place string 'D5' into print buffer 
00003060  6600 0010               2331          BNE     Data6
00003064  41F9 0000143E           2332          LEA     d5MSG,A0
0000306A  4EB9 00001102           2333          JSR     ADD2BUFFER
00003070  4E75                    2334          RTS
00003072                          2335  
00003072                          2336  Data6:  
00003072  B83C 0006               2337          CMP.B   #$6,D4      ;If 6, place string 'D6' into print buffer 
00003076  6600 0010               2338          BNE     Data7
0000307A  41F9 00001441           2339          LEA     d6MSG,A0
00003080  4EB9 00001102           2340          JSR     ADD2BUFFER
00003086  4E75                    2341          RTS
00003088                          2342  
00003088                          2343  Data7:  
00003088  B83C 0007               2344          CMP.B   #$7,D4      ;If 7, place string 'D7' into print buffer 
0000308C  41F9 00001444           2345          LEA     d7MSG,A0
00003092  4EB9 00001102           2346          JSR     ADD2BUFFER
00003098  4E75                    2347          RTS
0000309A                          2348  
0000309A                          2349  
0000309A                          2350  
0000309A                          2351  
0000309A                          2352  
0000309A                          2353  ADDRREG:
0000309A                          2354              
0000309A  3803                    2355          MOVE.W  D3, D4      ;Move a copy of D3 into D4 for manipulation
0000309C                          2356          
0000309C  B43C 0001               2357          CMP.B   #$1, D2     ; Check if move flag set
000030A0  6700 000C               2358          BEQ     Bitm_ar     ; branch if equal to bit masking
000030A4  103C 0009               2359          MOVE.B  #$9,D0      ; Move 9 into register D0
000030A8  E06C                    2360          LSR.W   D0, D4      ; Shift right 9 times for move_ea
000030AA  6000 0002               2361          BRA     Bitm_ar     ; branch to bit masking
000030AE                          2362          
000030AE                          2363          
000030AE  0244 0007               2364  Bitm_ar  ANDI.W  #$0007,D4  ;Bit mask 3 bits from LSB  
000030B2  4242                    2365           CLR.W   D2         ;Clear the flag        
000030B4                          2366          
000030B4                          2367          
000030B4                          2368  Ar0:
000030B4  B83C 0000               2369          CMP.B   #$0,D4      ;If 0, place string 'A0' into print buffer 
000030B8  6600 0010               2370          BNE     Ar1
000030BC  41F9 00001447           2371          LEA     ar0MSG,A0
000030C2  4EB9 00001102           2372          JSR     ADD2BUFFER
000030C8  4E75                    2373          RTS
000030CA                          2374  
000030CA                          2375  Ar1:  
000030CA  B83C 0001               2376          CMP.B   #$1,D4      ;if 1, place string 'A1' into print buffer
000030CE  6600 0010               2377          BNE     Ar2
000030D2  41F9 0000144A           2378          LEA     ar1MSG,A0
000030D8  4EB9 00001102           2379          JSR     ADD2BUFFER
000030DE  4E75                    2380          RTS
000030E0                          2381          
000030E0                          2382  Ar2:  
000030E0  B83C 0002               2383          CMP.B   #$2,D4      ;if 2, place string 'A2' into print buffer
000030E4  6600 0010               2384          BNE     Ar3
000030E8  41F9 0000144D           2385          LEA     ar2MSG,A0
000030EE  4EB9 00001102           2386          JSR     ADD2BUFFER
000030F4  4E75                    2387          RTS
000030F6                          2388  
000030F6                          2389  Ar3:  
000030F6  B83C 0003               2390          CMP.B   #$3,D4      ;if 3, place string 'A3' into print buffer
000030FA  6600 0010               2391          BNE     Ar4
000030FE  41F9 00001450           2392          LEA     ar3MSG,A0
00003104  4EB9 00001102           2393          JSR     ADD2BUFFER
0000310A  4E75                    2394          RTS
0000310C                          2395          
0000310C                          2396  Ar4:  
0000310C  B83C 0004               2397          CMP.B   #$4,D4      ;if 4, place string 'A4' into print buffer
00003110  6600 0010               2398          BNE     Ar5
00003114  41F9 00001453           2399          LEA     ar4MSG,A0
0000311A  4EB9 00001102           2400          JSR     ADD2BUFFER
00003120  4E75                    2401          RTS
00003122                          2402      
00003122                          2403  Ar5:  
00003122  B83C 0005               2404          CMP.B   #$5,D4      ;if 5, place string 'A5' into print buffer
00003126  6600 0010               2405          BNE     Ar6
0000312A  41F9 00001456           2406          LEA     ar5MSG,A0
00003130  4EB9 00001102           2407          JSR     ADD2BUFFER
00003136  4E75                    2408          RTS
00003138                          2409  
00003138                          2410  Ar6:  
00003138  B83C 0006               2411          CMP.B   #$6,D4      ;if 6, place string 'A6' into print buffer
0000313C  6600 0010               2412          BNE     Ar7
00003140  41F9 00001459           2413          LEA     ar6MSG,A0
00003146  4EB9 00001102           2414          JSR     ADD2BUFFER
0000314C  4E75                    2415          RTS
0000314E                          2416  
0000314E                          2417  Ar7:  
0000314E  B83C 0007               2418          CMP.B   #$7,D4      ;if 7, place string 'A7' into print buffer
00003152  41F9 0000145C           2419          LEA     ar7MSG,A0
00003158  4EB9 00001102           2420          JSR     ADD2BUFFER
0000315E  4E75                    2421          RTS
00003160                          2422  
00003160                          2423  
00003160                          2424  
00003160                          2425  ADDRESS:
00003160                          2426          
00003160  3803                    2427          MOVE.W  D3, D4      ;Move a copy of D3 into D4 for manipulation
00003162                          2428          
00003162  B43C 0001               2429          CMP.B   #$1, D2     ; Check if move flag set
00003166  6700 000C               2430          BEQ     Bitm_a      ; branch if equal to bit masking
0000316A  103C 0009               2431          MOVE.B  #$9,D0      ; Move 9 into register D0
0000316E  E06C                    2432          LSR.W   D0, D4      ; Shift right 9 times for move_ea
00003170  6000 0002               2433          BRA     Bitm_a      ; branch to bit masking
00003174                          2434          
00003174                          2435          
00003174  0244 0007               2436  Bitm_a  ANDI.W  #$0007,D4  ;Bit mask 3 bits from LSB  
00003178  4242                    2437          CLR.W   D2         ;Clear the flag 
0000317A                          2438          
0000317A                          2439  Ari0:
0000317A  B83C 0000               2440          CMP.B   #$0,D4      ;if 0, place string '(A0)' into print buffer
0000317E  6600 0010               2441          BNE     Ari1
00003182  41F9 0000145F           2442          LEA     ari0MSG,A0
00003188  4EB9 00001102           2443          JSR     ADD2BUFFER
0000318E  4E75                    2444          RTS
00003190                          2445  
00003190                          2446  Ari1:  
00003190  B83C 0001               2447          CMP.B   #$1,D4      ;if 1, place string '(A1)' into print buffer
00003194  6600 0010               2448          BNE     Ari2
00003198  41F9 00001464           2449          LEA     ari1MSG,A0
0000319E  4EB9 00001102           2450          JSR     ADD2BUFFER
000031A4  4E75                    2451          RTS
000031A6                          2452          
000031A6                          2453  Ari2:  
000031A6  B83C 0002               2454          CMP.B   #$2,D4      ;if 2, place string '(A2)' into print buffer
000031AA  6600 0010               2455          BNE     Ari3
000031AE  41F9 00001469           2456          LEA     ari2MSG,A0
000031B4  4EB9 00001102           2457          JSR     ADD2BUFFER
000031BA  4E75                    2458          RTS
000031BC                          2459  
000031BC                          2460  Ari3:  
000031BC  B83C 0003               2461          CMP.B   #$3,D4      ;if 3, place string '(A3)' into print buffer
000031C0  6600 0010               2462          BNE     Ari4
000031C4  41F9 0000146E           2463          LEA     ari3MSG,A0
000031CA  4EB9 00001102           2464          JSR     ADD2BUFFER
000031D0  4E75                    2465          RTS
000031D2                          2466          
000031D2                          2467  Ari4:  
000031D2  B83C 0004               2468          CMP.B   #$4,D4      ;if 4, place string '(A4)' into print buffer
000031D6  6600 0010               2469          BNE     Ari5
000031DA  41F9 00001473           2470          LEA     ari4MSG,A0
000031E0  4EB9 00001102           2471          JSR     ADD2BUFFER
000031E6  4E75                    2472          RTS
000031E8                          2473      
000031E8                          2474  Ari5:  
000031E8  B83C 0005               2475          CMP.B   #$5,D4      ;if 5, place string '(A5)' into print buffer
000031EC  6600 0010               2476          BNE     Ari6
000031F0  41F9 00001478           2477          LEA     ari5MSG,A0
000031F6  4EB9 00001102           2478          JSR     ADD2BUFFER
000031FC  4E75                    2479          RTS
000031FE                          2480  
000031FE                          2481  Ari6:  
000031FE  B83C 0006               2482          CMP.B   #$6,D4      ;if 6, place string '(A6)' into print buffer
00003202  6600 0010               2483          BNE     Ari7
00003206  41F9 0000147D           2484          LEA     ari6MSG,A0
0000320C  4EB9 00001102           2485          JSR     ADD2BUFFER
00003212  4E75                    2486          RTS
00003214                          2487  
00003214                          2488  Ari7:  
00003214  B83C 0007               2489          CMP.B   #$7,D4      ;if 7, place string '(A7)' into print buffer
00003218  41F9 00001482           2490          LEA     ari7MSG,A0
0000321E  4EB9 00001102           2491          JSR     ADD2BUFFER
00003224  4E75                    2492          RTS
00003226                          2493  
00003226                          2494  
00003226                          2495  
00003226                          2496  
00003226                          2497  
00003226                          2498  
00003226                          2499  ADDRPOST:
00003226                          2500                  
00003226  3803                    2501          MOVE.W  D3, D4      ;Move a copy of D3 into D4 for manipulation
00003228                          2502          
00003228  B43C 0001               2503          CMP.B   #$1, D2     ; Check if move flag set
0000322C  6700 000C               2504          BEQ     Bitm_ap     ; branch if equal to bit masking
00003230  103C 0009               2505          MOVE.B  #$9,D0      ; Move 9 into register D0
00003234  E06C                    2506          LSR.W   D0, D4      ; Shift right 9 times for move_ea
00003236  6000 0002               2507          BRA     Bitm_ap     ; branch to bit masking
0000323A                          2508          
0000323A                          2509          
0000323A  0244 0007               2510  Bitm_ap  ANDI.W  #$0007,D4  ;Bit mask 3 bits from LSB  
0000323E  4242                    2511           CLR.W   D2         ;Clear the flag   
00003240                          2512          
00003240                          2513  Arpi0:
00003240  B83C 0000               2514          CMP.B   #$0,D4      ;if 0, place string '(A0)+' into print buffer
00003244  6600 0010               2515          BNE     Arpi1
00003248  41F9 00001487           2516          LEA     arpi0MSG,A0
0000324E  4EB9 00001102           2517          JSR     ADD2BUFFER
00003254  4E75                    2518          RTS
00003256                          2519  
00003256                          2520  Arpi1:  
00003256  B83C 0001               2521          CMP.B   #$1,D4      ;if 1, place string '(A1)+' into print buffer
0000325A  6600 0010               2522          BNE     Arpi2
0000325E  41F9 0000148D           2523          LEA     arpi1MSG,A0
00003264  4EB9 00001102           2524          JSR     ADD2BUFFER
0000326A  4E75                    2525          RTS
0000326C                          2526          
0000326C                          2527  Arpi2:  
0000326C  B83C 0002               2528          CMP.B   #$2,D4      ;if 2, place string '(A2)+' into print buffer
00003270  6600 0010               2529          BNE     Arpi3
00003274  41F9 00001493           2530          LEA     arpi2MSG,A0
0000327A  4EB9 00001102           2531          JSR     ADD2BUFFER
00003280  4E75                    2532          RTS
00003282                          2533  
00003282                          2534  Arpi3:  
00003282  B83C 0003               2535          CMP.B   #$3,D4      ;if 3, place string '(A3)+' into print buffer
00003286  6600 0010               2536          BNE     Arpi4
0000328A  41F9 00001499           2537          LEA     arpi3MSG,A0
00003290  4EB9 00001102           2538          JSR     ADD2BUFFER
00003296  4E75                    2539          RTS
00003298                          2540          
00003298                          2541  Arpi4:  
00003298  B83C 0004               2542          CMP.B   #$4,D4      ;if 4, place string '(A4)+' into print buffer
0000329C  6600 0010               2543          BNE     Arpi5
000032A0  41F9 0000149F           2544          LEA     arpi4MSG,A0
000032A6  4EB9 00001102           2545          JSR     ADD2BUFFER
000032AC  4E75                    2546          RTS
000032AE                          2547      
000032AE                          2548  Arpi5:  
000032AE  B83C 0005               2549          CMP.B   #$5,D4      ;if 5, place string '(A5)+' into print buffer
000032B2  6600 0010               2550          BNE     Arpi6
000032B6  41F9 000014A5           2551          LEA     arpi5MSG,A0
000032BC  4EB9 00001102           2552          JSR     ADD2BUFFER
000032C2  4E75                    2553          RTS
000032C4                          2554  
000032C4                          2555  Arpi6:  
000032C4  B83C 0006               2556          CMP.B   #$6,D4      ;if 6, place string '(A6)+' into print buffer
000032C8  6600 0010               2557          BNE     Arpi7
000032CC  41F9 000014AB           2558          LEA     arpi6MSG,A0
000032D2  4EB9 00001102           2559          JSR     ADD2BUFFER
000032D8  4E75                    2560          RTS
000032DA                          2561  
000032DA                          2562  Arpi7:  
000032DA  B83C 0007               2563          CMP.B   #$7,D4      ;if 7, place string '(A7)+' into print buffer
000032DE  41F9 000014B1           2564          LEA     arpi7MSG,A0
000032E4  4EB9 00001102           2565          JSR     ADD2BUFFER
000032EA  4E75                    2566          RTS
000032EC                          2567          
000032EC                          2568  ADDRPRE:
000032EC                          2569          
000032EC  3803                    2570          MOVE.W  D3, D4      ; Move a copy of D3 into D4 for manipulation
000032EE                          2571          
000032EE  B43C 0001               2572          CMP.B   #$1, D2     ; Check if move flag set
000032F2  6700 000C               2573          BEQ     Bitm_apre   ; Branch if equal to bit masking
000032F6  103C 0009               2574          MOVE.B  #$9,D0      ; Move 9 into register D0
000032FA  E06C                    2575          LSR.W   D0, D4      ; Shift right 9 times for move_ea
000032FC  6000 0002               2576          BRA     Bitm_apre   ; Branch to bit masking
00003300                          2577          
00003300                          2578          
00003300  0244 0007               2579  Bitm_apre   ANDI.W  #$0007,D4  ; Bit mask 3 bits from LSB  
00003304  4242                    2580              CLR.W   D2         ; Clear the flag
00003306                          2581          
00003306                          2582  Adrpi0:
00003306  B83C 0000               2583          CMP.B   #$0,D4      ;if 0, place string '-(A0)' into print buffer
0000330A  6600 0010               2584          BNE     Adrpi1
0000330E  41F9 000014B7           2585          LEA     arpd0MSG,A0
00003314  4EB9 00001102           2586          JSR     ADD2BUFFER
0000331A  4E75                    2587          RTS
0000331C                          2588  
0000331C                          2589  Adrpi1:  
0000331C  B83C 0001               2590          CMP.B   #$1,D4      ;if 1, place string '-(A1)' into print buffer
00003320  6600 0010               2591          BNE     Adrpi2
00003324  41F9 000014BD           2592          LEA     arpd1MSG,A0
0000332A  4EB9 00001102           2593          JSR     ADD2BUFFER
00003330  4E75                    2594          RTS
00003332                          2595          
00003332                          2596  Adrpi2:  
00003332  B83C 0002               2597          CMP.B   #$2,D4      ;if 2, place string '-(A2)' into print buffer
00003336  6600 0010               2598          BNE     Adrpi3
0000333A  41F9 000014C3           2599          LEA     arpd2MSG,A0
00003340  4EB9 00001102           2600          JSR     ADD2BUFFER
00003346  4E75                    2601          RTS
00003348                          2602  
00003348                          2603  Adrpi3:  
00003348  B83C 0003               2604          CMP.B   #$3,D4      ;if 3, place string '-(A3)' into print buffer
0000334C  6600 0010               2605          BNE     Adrpi4
00003350  41F9 000014C9           2606          LEA     arpd3MSG,A0
00003356  4EB9 00001102           2607          JSR     ADD2BUFFER
0000335C  4E75                    2608          RTS
0000335E                          2609          
0000335E                          2610  Adrpi4:  
0000335E  B83C 0004               2611          CMP.B   #$4,D4      ;if 4, place string '-(A4)' into print buffer
00003362  6600 0010               2612          BNE     Adrpi5
00003366  41F9 000014CF           2613          LEA     arpd4MSG,A0
0000336C  4EB9 00001102           2614          JSR     ADD2BUFFER
00003372  4E75                    2615          RTS
00003374                          2616      
00003374                          2617  Adrpi5:  
00003374  B83C 0005               2618          CMP.B   #$5,D4      ;if 5, place string '-(A5)' into print buffer
00003378  6600 0010               2619          BNE     Adrpi6
0000337C  41F9 000014D5           2620          LEA     arpd5MSG,A0
00003382  4EB9 00001102           2621          JSR     ADD2BUFFER
00003388  4E75                    2622          RTS
0000338A                          2623  
0000338A                          2624  Adrpi6:  
0000338A  B83C 0006               2625          CMP.B   #$6,D4      ;if 6, place string '-(A6)' into print buffer
0000338E  6600 0010               2626          BNE     Adrpi7
00003392  41F9 000014DB           2627          LEA     arpd6MSG,A0
00003398  4EB9 00001102           2628          JSR     ADD2BUFFER
0000339E  4E75                    2629          RTS
000033A0                          2630  
000033A0                          2631  Adrpi7:  
000033A0  B83C 0007               2632          CMP.B   #$7,D4      ;if 7, place string '-(A7)' into print buffer
000033A4  41F9 000014E1           2633          LEA     arpd7MSG,A0
000033AA  4EB9 00001102           2634          JSR     ADD2BUFFER
000033B0  4E75                    2635          RTS
000033B2                          2636  
000033B2                          2637  
000033B2                          2638  
000033B2                          2639  
000033B2                          2640  
000033B2                          2641  
000033B2                          2642  
000033B2                          2643  ABSSHORT:
000033B2                          2644              
000033B2                          2645              
000033B2  41F9 000012EE           2646              LEA     hexSign, A0   ;load message "$"
000033B8  4EB9 00001102           2647              JSR     ADD2BUFFER    ;add message to printBuffer
000033BE                          2648  
000033BE                          2649  
000033BE  4284                    2650              CLR.L   D4      ;clear register  
000033C0  4280                    2651              CLR.L   D0      ;clear register                      
000033C2  381B                    2652              MOVE.W  (A3)+,D4 ;load the word
000033C4  103C 0010               2653              MOVE.B  #16,D0      ;load length of hex value
000033C8  4EB9 0000110C           2654              JSR     HexToAscii  ;convert to ascii, puts in hex2ascBuffer
000033CE  41F9 000012DE           2655              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
000033D4  4EB9 00001102           2656              JSR     ADD2BUFFER      ;add word to buffer
000033DA                          2657  
000033DA  4E75                    2658              RTS
000033DC                          2659  
000033DC                          2660  
000033DC                          2661  ABSLONG:
000033DC                          2662          
000033DC  41F9 000012EE           2663              LEA     hexSign, A0   ;load message "$"
000033E2  4EB9 00001102           2664              JSR     ADD2BUFFER    ;add message to printBuffer
000033E8                          2665  
000033E8                          2666  
000033E8  4284                    2667              CLR.L   D4      ;clear register  
000033EA  4280                    2668              CLR.L   D0      ;clear register                      
000033EC  281B                    2669              MOVE.L  (A3)+,D4 ;load the long
000033EE  103C 0020               2670              MOVE.B  #32,D0      ;load length of hex value
000033F2  4EB9 0000110C           2671              JSR     HexToAscii  ;convert to ascii, puts in hex2ascBuffer
000033F8  41F9 000012DE           2672              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
000033FE  4EB9 00001102           2673              JSR     ADD2BUFFER      ;add word to buffer
00003404                          2674  
00003404  4E75                    2675              RTS
00003406                          2676  
00003406                          2677  
00003406                          2678  IMMED:      
00003406  41F9 000012EC           2679              LEA     hashtag, A0   ;load message "#"
0000340C  4EB9 00001102           2680              JSR     ADD2BUFFER    ;add message to printBuffer           
00003412  41F9 000012EE           2681              LEA     hexSign, A0   ;load message "$"
00003418  4EB9 00001102           2682              JSR     ADD2BUFFER    ;add message to printBuffer
0000341E                          2683              
0000341E  BC3C 0008               2684              CMP.B   #8, D6        ;is it a byte?
00003422  6600 0022               2685              BNE     size_word     ;if no, skip to next comparison            
00003426                          2686  size_byte:
00003426  4284                    2687              CLR.L   D4            ;clear register  
00003428  4280                    2688              CLR.L   D0            ;clear register
0000342A  384B                    2689              MOVE.W  A3, A4        ;update address pointer incase opcode still can't be decoded at some point
0000342C  381B                    2690              MOVE.W  (A3)+, D4     ;grab the immediate data from the word after the opcode
0000342E  103C 0008               2691              MOVE.B  #8,D0         ;load length of hex value
00003432  4EB9 0000110C           2692              JSR     HexToAscii    ;convert to ascii, puts in hex2ascBuffer
00003438  41F9 000012DE           2693              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
0000343E  4EB9 00001102           2694              JSR     ADD2BUFFER      ;add immediate value to buffer
00003444                          2695              
00003444  4E75                    2696              RTS             
00003446                          2697  
00003446                          2698  size_word:
00003446  BC3C 0010               2699              CMP.B   #16, D6       ;is it a word?
0000344A  6600 0022               2700              BNE     size_long     ;if no, skip to next comparison
0000344E                          2701              
0000344E  4284                    2702              CLR.L   D4            ;clear register  
00003450  4280                    2703              CLR.L   D0            ;clear register
00003452  384B                    2704              MOVE.W  A3, A4        ;update address pointer incase opcode still can't be decoded at some point
00003454  381B                    2705              MOVE.W  (A3)+, D4     ;grab the immediate data from the word after the opcode
00003456  103C 0010               2706              MOVE.B  #16, D0       ;load length of hex value
0000345A  4EB9 0000110C           2707              JSR     HexToAscii    ;convert to ascii, puts in hex2ascBuffer
00003460  41F9 000012DE           2708              LEA     hex2ascBuffer, A0  ;load ascii buffer  for printing
00003466  4EB9 00001102           2709              JSR     ADD2BUFFER      ;add immediate value to buffer
0000346C                          2710  
0000346C  4E75                    2711              RTS         
0000346E                          2712  
0000346E                          2713  
0000346E                          2714  size_long:            
0000346E  BC3C 0020               2715              CMP.B   #32, D6      ;is it a long?
00003472  6600 F742               2716              BNE     BADFLAG      ;if no, can't be decoded   
00003476                          2717              
00003476  4284                    2718              CLR.L   D4            ;clear register  
00003478  4280                    2719              CLR.L   D0            ;clear register
0000347A  384B                    2720              MOVE.W  A3, A4        ;update address pointer incase opcode still can't be decoded at some point
0000347C  281B                    2721              MOVE.L  (A3)+, D4     ;grab the immediate data from the long after the opcode
0000347E  103C 0020               2722              MOVE.B  #32,D0        ;load length of hex value
00003482  4EB9 0000110C           2723              JSR     HexToAscii    ;convert to ascii, puts in hex2ascBuffer
00003488  41F9 000012DE           2724              LEA     hex2ascBuffer, A0  ;load ascii buffer  for printing
0000348E  4EB9 00001102           2725              JSR     ADD2BUFFER      ;add immediate value to buffer
00003494                          2726  
00003494  4E75                    2727              RTS
00003496                          2728  
00003496                          2729  
00003496                          2730  
00003496                          2731  
00003496                          2732  
00003496                          2733  
00003496                          2734  
00003496                          2735  
00003496                          2736  -------------------- end include --------------------
00003496                          2737  
00003496                          2738  *******************************************************************************
00003496                          2739  * Method Name: DISASSEMBLER
00003496                          2740  * Description: Loads starting address into register A3 and compares it to the
00003496                          2741  * ending address in A4, ends program when equal. Otherwise loops through continuously
00003496                          2742  * printing the disassembled opcode or printing the address and data for
00003496                          2743  * non-decodable words. 
00003496                          2744  * 
00003496                          2745  * General Registers:
00003496                          2746  *   A3 = pointer to current address (next address after postincrement)
00003496                          2747  *   A4 = Copy of current address in case opcode can't be decoded
00003496                          2748  *   D3 = current opcode, read only till program re-loops
00003496                          2749  *   D4 = working opcode for masking, shifting, etc.
00003496                          2750  *   D5 = good/bad flag, 1=good 0=bad
00003496                          2751  *   D6 = size for EA decode of immediate data
00003496                          2752  *
00003496                          2753  * Printing Buffers and Registers:
00003496                          2754  *   - printBuffer = address of buffer for printing final multi-string to I/O
00003496                          2755  *   A1 = Pointer to current location in printBuffer (set by opcode person, EA does not change)
00003496                          2756  *   A0 = Pointer to string/constant to be added to printBuffer. Must LEA string/constant before calling "ADD2BUFFER" method.
00003496                          2757  *   - hex2ascBuffer = converted ascii value/string stored here after calling "HexToAscii"
00003496                          2758  *
00003496                          2759  * Preconditions:  None
00003496                          2760  * Postconditions: TBD
00003496                          2761  *********************************************************************************
00003496                          2762  
00001000                          2763      ORG     $1000
00001000                          2764  
00001000                          2765  DISASSEMBLER:
00001000  103C 0032               2766              MOVE.B  #50, D0
00001004  4E4F                    2767              TRAP    #15        ;close any open files
00001006                          2768              
00001006  103C 0033               2769              MOVE.B  #51, D0
0000100A  43F9 00001260           2770              LEA     configFile, A1
00001010  4E4F                    2771              TRAP    #15         ;open config.cfg file
00001012                          2772              
00001012  43F9 0000126B           2773              LEA     fileBuffer, A1  ;load file buffer
00001018  7408                    2774              MOVE.L  #8, D2      ;bytes to read
0000101A  103C 0035               2775              MOVE.B  #53, D0     ;read from config.cfg file into buffer (first 8 bytes = start address)
0000101E  4E4F                    2776              TRAP    #15
00001020                          2777              
00001020  4EB9 000011F4           2778              JSR     AsciiToHex    ;convert it to Hex
00001026  2647                    2779              MOVE.L  D7, A3        ;load start addr into A3
00001028                          2780  
00001028                          2781  
00001028  43F9 0000126B           2782              LEA     fileBuffer, A1  ;load file buffer
0000102E  7402                    2783              MOVE.L  #2, D2      ;bytes to read
00001030  103C 0035               2784              MOVE.B  #53, D0     ;read from config.cfg file into buffer
00001034  4E4F                    2785              TRAP    #15         ;this just discards the 2 byte LF/CR in the file
00001036                          2786              
00001036  43F9 0000126B           2787              LEA     fileBuffer, A1  ;load file buffer
0000103C  7408                    2788              MOVE.L  #8, D2      ;bytes to read
0000103E  103C 0035               2789              MOVE.B  #53, D0     ;read from config.cfg file into buffer (last 8 bytes = end address)
00001042  4E4F                    2790              TRAP    #15
00001044                          2791              
00001044  4EB9 000011F4           2792              JSR     AsciiToHex    ;convert it to Hex
0000104A  2A47                    2793              MOVE.L  D7, A5        ;load end addr into A5
0000104C                          2794              
0000104C                          2795  
0000104C                          2796  ************************* Start Dissasembler Loop *************************
0000104C                          2797  DISLOOP:    
0000104C  BBCB                    2798              CMPA.L  A3, A5     ; does the reading address equal the end address?
0000104E  6F00 00AE               2799              BLE     ENDPROG    ;if so, nothing else to read, jumpt to end of program
00001052                          2800            
00001052  1A3C 0001               2801              MOVE.B  #1,D5      ;set flag to good
00001056  43F9 0000128E           2802              LEA     printBuffer,A1  ;load the printBuffer          
0000105C  280B                    2803              MOVE.L  A3,D4     ;load address as a number to print
0000105E  4280                    2804              CLR.L   D0          ;clear register
00001060  103C 0010               2805              MOVE.B  #16, D0         ;set address size for hex to ascii conversion
00001064  4EB9 0000110C           2806              JSR     HexToAscii      ;convert address to ascii, puts in hex2ascBuffer
0000106A  41F9 000012DE           2807              LEA     hex2ascBuffer,A0    ;load ascii buffer with address
00001070  4EB9 00001102           2808              JSR     ADD2BUFFER     ;add address to printBuffer
00001076                          2809              
00001076  4EB8 1504               2810              JSR     OPCODE      ; start to decode in opcode.x68
0000107A                          2811              
0000107A  BA7C 0001               2812              CMP     #1,D5       ;on return, check if flag is still good
0000107E  6600 0016               2813              BNE     CANTDECODE     ;if not, print undecoded data
00001082                          2814              
00001082  12BC 0000               2815              MOVE.B  #0,(A1)        ;else, successfull decode, add null deliminator to completed string
00001086  43F9 0000128E           2816              LEA     printBuffer,A1 ;reload print buffer for printing finished string
0000108C  4EB9 0000115E           2817              JSR     TrapTask13      ;print it
00001092                          2818              
00001092  4EF8 104C               2819              JMP     DISLOOP     ;continue loop  
00001096                          2820             
00001096                          2821              
00001096                          2822              
00001096                          2823  CANTDECODE:   *opcode can't be decoded, print address and data
00001096  43F9 0000128E           2824              LEA     printBuffer,A1  ;reload the printBuffer in case any strings were written in the decode, before failing                                                                                                
0000109C                          2825              
0000109C  280C                    2826              MOVE.L  A4,D4           ;reload address as a number to print
0000109E  4280                    2827              CLR.L   D0              ;clear register
000010A0  103C 0010               2828              MOVE.B  #16, D0         ;set address size for hex to ascii conversion
000010A4  4EB9 0000110C           2829              JSR     HexToAscii      ;convert address to ascii, puts in hex2ascBuffer
000010AA  41F9 000012DE           2830              LEA     hex2ascBuffer,A0    ;load ascii buffer with address
000010B0  4EB9 00001102           2831              JSR     ADD2BUFFER     ;add address to printBuffer
000010B6                          2832              
000010B6  41F9 000012F4           2833              LEA     dataMSG,A0     ;load message "DATA"
000010BC  4EB9 00001102           2834              JSR     ADD2BUFFER     ;add message to printBuffer
000010C2                          2835  
000010C2  41F9 000012EE           2836              LEA     hexSign, A0   ;load message "$"
000010C8  4EB9 00001102           2837              JSR     ADD2BUFFER    ;add message to printBuffer
000010CE                          2838              
000010CE  4284                    2839              CLR.L   D4      ;clear register  
000010D0  4280                    2840              CLR.L   D0      ;clear register                      
000010D2  3814                    2841              MOVE.W  (A4),D4 ;load the undecodable word
000010D4  103C 0010               2842              MOVE.B  #16,D0      ;load length of hex value
000010D8  4EB9 0000110C           2843              JSR     HexToAscii  ;convert to ascii, puts in hex2ascBuffer
000010DE  41F9 000012DE           2844              LEA     hex2ascBuffer,A0  ;load ascii buffer  for printing
000010E4  4EB9 00001102           2845              JSR     ADD2BUFFER      ;add word to buffer
000010EA                          2846              
000010EA  12BC 0000               2847              MOVE.B  #0,(A1)         ;add null deliminator to completed string
000010EE  43F9 0000128E           2848              LEA     printBuffer,A1  ;reload print buffer for printing finished string
000010F4  4EB9 0000115E           2849              JSR     TrapTask13
000010FA                          2850              
000010FA  4EF8 104C               2851              JMP     DISLOOP     ;continue loop  
000010FE                          2852  
000010FE                          2853  
000010FE                          2854  
000010FE                          2855  ENDPROG:    * End of the program
000010FE                          2856  
000010FE  FFFF FFFF               2857      SIMHALT
00001102                          2858    
00001102                          2859    
00001102                          2860  
00001102                          2861  
00001102                          2862  
00001102                          2863  *********************************************************************************
00001102                          2864  * Method Name:    ADD2BUFFER
00001102                          2865  * Written by : Midori Williams
00001102                          2866  *
00001102                          2867  * Description:    Adds an ascii string from A0 to the current possition in printBuffer
00001102                          2868  *                 pointed to by A1
00001102                          2869  *
00001102                          2870  * Preconditions:  ascii/constant string address is loaded into A0
00001102                          2871  *                 printBuffer address is loaded into A1 
00001102                          2872  *
00001102                          2873  * Postconditions: ascii string/constant is now appended to printBuffer
00001102                          2874  *                 A1 postincrememnted to point to the next spot in the printBuffer   
00001102                          2875  *********************************************************************************
00001102                          2876  ADD2BUFFER:
00001102  12D8                    2877              MOVE.B  (A0)+,(A1)+     ;copy char from A0 to buffer
00001104  0C10 0000               2878              CMP.B   #$00,(A0)     ;end of input string? (null delimited)  
00001108  66F8                    2879              BNE     ADD2BUFFER    ;if not, copy another byte        
0000110A  4E75                    2880              RTS                 ;return to caller with buffer filled        
0000110C                          2881          
0000110C                          2882          
0000110C                          2883          
0000110C                          2884      
0000110C                          2885   
0000110C                          2886  *----------------------------------------------------------------------------------
0000110C                          2887  * Method Name: HexToAscii
0000110C                          2888  * Written by : Midori Williams
0000110C                          2889  *
0000110C                          2890  * Description: Converts hex vals 0-9,A-F a byte at a tiFe to Ascii chars '0'-'9' and 'A'-'F' 
0000110C                          2891  *              Transforms 1, 2, or 4 Bytes in D4 into 
0000110C                          2892  *              its 2, 4, or 8 Byte (8 bits each) equivalent Ascii value 
0000110C                          2893  *              Number size is stored in D0
0000110C                          2894  *  
0000110C                          2895  *  Preconditions & Input:
0000110C                          2896  *       D4 (input) stores value to be converted 
0000110C                          2897  *       D0 stores bit value length (#4, #8, #16, or #32)
0000110C                          2898  *       Assumptions: D0 contains valid length
0000110C                          2899  *       This function calls another function (add_ascii)
0000110C                          2900  *
0000110C                          2901  *  Postconditions & Output:
0000110C                          2902  *       hex2ascBuffer (output) points to a memory buffer holding ascii chars (null-terminated)
0000110C                          2903  *----------------------------------------------------------------------------------
0000110C                          2904  HexToAscii     
0000110C                          2905              **initialize variables**
0000110C  4DF9 000012DE           2906              LEA hex2ascBuffer,A6 *load buffer
00001112  4282                    2907              CLR.L   D2      *empty contents for use as temp number storage for conversion
00001114  4281                    2908              CLR.L   D1      *empty contents for use as bit-shift counter in convLoop
00001116  1200                    2909              MOVE.B  D0,D1   *copy number length
00001118  5901                    2910              SUBI.B  #4,D1   *value is shifted 1x fewer than the bit length of number
0000111A                          2911             
0000111A                          2912  convLoop    
0000111A                          2913              **start looping**
0000111A  2404                    2914              MOVE.L  D4,D2   *copy hex value into D2 for 4-bit masking
0000111C  E2AA                    2915              LSR.L   D1,D2   *shift 4 decode bits to far right to isolate
0000111E  C4BC 0000000F           2916              AND.L   #$0000000F,D2  *mask all but 4 decode bits
00001124  4EB9 0000113C           2917              JSR     add_ascii   *do 4 bit conversion to ascii, new value is 8 bits (Byte)    
0000112A  1CC2                    2918              MOVE.B  D2,(A6)+    *add to buffer
0000112C                          2919              
0000112C  5900                    2920              SUBI.B  #4,D0   *decrement our size/loop variable
0000112E  6700 0006               2921              BEQ     convDone   *skip to end if we are done 
00001132                          2922  
00001132  5901                    2923              SUBI.B  #4,D1  *decrease bit-shift counter
00001134  60E4                    2924              BRA     convLoop   *repeat loop on next 4 bits      
00001136                          2925  
00001136                          2926  convDone
00001136  1CBC 0000               2927              MOVE.B  #0,(A6) *set null deliminator
0000113A  4E75                    2928              RTS
0000113C                          2929  **********************************************************************
0000113C                          2930  * SUBROUTINE for HexToAscii: add_ascii
0000113C                          2931  * add the ascii code to the digits 0-9 or A-F
0000113C                          2932  * Input Parameters: <D3> = 4 bit Hex value
0000113C                          2933  *
0000113C                          2934  * Return parameters: D3.B = number 0...F, returned as $30-$39 or $41-$46
0000113C                          2935  * Registers used internally: D3
0000113C                          2936  * Assumptions: D3 contains 0-9 or A-F
0000113C                          2937  *
0000113C                          2938  ***********************************************************************
0000113C                          2939  add_ascii
0000113C  B43C 000A               2940              CMP.B #$A,D2 * Is it A...F?
00001140  6C00 000E               2941              BGE add37 * Its A...F
00001144  B43C 0000               2942              CMP.B #$0,D2 * Is it in range of 0-9?
00001148  6C00 000E               2943              BGE add30 * Its a number
0000114C  6000 000E               2944              BRA ret_a2h * Go back
00001150  0602 0037               2945  add37       ADD.B #$37,D2 * Add 37
00001154  6000 0006               2946              BRA ret_a2h * Go back
00001158  0602 0030               2947  add30       ADD.B #$30,D2 * Add 30
0000115C  4E75                    2948  ret_a2h     RTS * Go back
0000115E                          2949  
0000115E                          2950  
0000115E                          2951  
0000115E                          2952  
0000115E                          2953  
0000115E                          2954  
0000115E                          2955  
0000115E                          2956  *********************************************************************************
0000115E                          2957  * Method Name:  TrapTask13
0000115E                          2958  * Description:  Creates a file if none exists, and appends bytes to that file
0000115E                          2959  *               while also echoing the written bytes to the screen.  You shouldn't 
0000115E                          2960  *               need to change this code.
0000115E                          2961  *
0000115E                          2962  * Calling Convention: Callee-Saved 
0000115E                          2963  *
0000115E                          2964  * Preconditions & Method Input:
0000115E                          2965  *   A1 points to the null-terminated buffer to write (newline will be added for you)
0000115E                          2966  *
0000115E                          2967  * Postconditions & Output:
0000115E                          2968  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
0000115E                          2969  *   See 'Output.txt' in directory for the results, also piped to the console
0000115E                          2970  *
0000115E                          2971  *
0000115E                          2972  *  A2 holds a pointer to null terminated string to write (input)
0000115E                          2973  *  A3 points to the null-terminated file name
0000115E                          2974  *  D3 holds the number of bytes already in the file to write
0000115E                          2975  *
0000115E                          2976  *  D5 holds number of bytes to write
0000115E                          2977  ********************************************************************************
0000115E                          2978  toSave REG D0-D5/A2-A3
0000115E                          2979  TrapTask13:
0000115E                          2980      *******************************************************************
0000115E                          2981      * Method initialization, regsiter spilling, parameter saving, etc.
0000115E                          2982      *******************************************************************
0000115E  48E7 FC30               2983      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore     
00001162                          2984      
00001162  2449                    2985      MOVEA.L A1, A2 ; save this buffer to write
00001164  47F9 00001255           2986      LEA outFilename, A3  ; save this for later, too
0000116A                          2987        
0000116A  303C 0032               2988      move #50,d0   
0000116E  4E4F                    2989      trap #15 ; close all files, suggested to begin any IO 
00001170                          2990      *******************************************************************
00001170                          2991      * End Method Init
00001170                          2992      *******************************************************************
00001170                          2993  
00001170                          2994      ******************************************************************************************
00001170                          2995      * Calculate the number of bytes to write by searching for the null in the target buffer A0
00001170                          2996      ******************************************************************************************
00001170  4285                    2997      CLR.L D5 *D5 is now the number of bytes to write
00001172                          2998  nullLoop:
00001172  1019                    2999      MOVE.B (A1)+, D0
00001174  0C00 0000               3000      CMPI.B #0,D0  * compare to null
00001178  6700 0006               3001      BEQ findNullLoopDone
0000117C  5245                    3002      ADDI.W #1, D5
0000117E  60F2                    3003      BRA nullLoop
00001180                          3004      
00001180                          3005  findNullLoopDone:
00001180  224B                    3006      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
00001182                          3007      
00001182                          3008      ;check if file exists, and open with task 51 if so, otherwise 52
00001182                          3009      ;(precondition here is A1 points to the null-terminated filename )
00001182  103C 0033               3010      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
00001186  4E4F                    3011      trap #15
00001188                          3012        
00001188                          3013      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
0000118E  103C 0034               3014          MOVE.B #52, D0             ; open new file (52 is new)
00001192  4E4F                    3015          trap #15
00001194                          3016      endi
00001194                          3017      
00001194                          3018      ********************************************************************************************************* 
00001194                          3019      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
00001194                          3020      *    (first, count number of bytes already in the file to obtain seek position)
00001194                          3021      *********************************************************************************************************
00001194  4283                    3022      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
00001196  7401                    3023      MOVE.L #1, D2 ; read one byte at a time
00001198  43F9 0000127F           3024      LEA byteRead, A1
0000119E                          3025      
0000119E                          3026  countLoop:
0000119E  103C 0035               3027      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
000011A2  4E4F                    3028      trap #15
000011A4                          3029      
000011A4  0C40 0001               3030      CMPI.W #1,D0  ;1 == EOF
000011A8  6700 0006               3031      BEQ countDone
000011AC  5243                    3032      ADDI #1, D3
000011AE  60EE                    3033      BRA countLoop
000011B0                          3034      
000011B0                          3035  countDone:    
000011B0                          3036      * close this file
000011B0  303C 0038               3037       move #56,d0  
000011B4  4E4F                    3038       trap #15 
000011B6                          3039       
000011B6                          3040       * reopen the target file
000011B6  224B                    3041       MOVE.L A3,A1
000011B8  303C 0033               3042       MOVE #51, D0
000011BC  4E4F                    3043       trap #15
000011BE                          3044       
000011BE                          3045      * seek to right position, then continue with writing
000011BE  2403                    3046      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
000011C0  303C 0037               3047      MOVE #55, D0  ; position file task
000011C4  4E4F                    3048      trap #15
000011C6                          3049  
000011C6                          3050      ******************************************************************************
000011C6                          3051      * Actually write the buffer to the file, after caculating the number of bytes 
000011C6                          3052      *  to write and after seeking to the right location in the file for append
000011C6                          3053      ******************************************************************************
000011C6                          3054  
000011C6  2405                    3055      MOVE.L D5, D2 ; restore this for the actually writing the buffer 
000011C8                          3056      ; assumes A0 hasnt changed since handed to this method      
000011C8  224A                    3057      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
000011CA                          3058      ; assumes file ID is still stored in D1.L  
000011CA  103C 0036               3059      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
000011CE  4E4F                    3060      trap #15
000011D0                          3061  
000011D0                          3062      ; add a newline to the file output
000011D0  43F9 000012E6           3063      LEA NEWLINE, A1
000011D6  103C 0036               3064      MOVE.B #54, D0 
000011DA  143C 0002               3065      MOVE.B #2,D2  ; kills # of bytes to write from input param
000011DE  4E4F                    3066      trap #15
000011E0                          3067      
000011E0                          3068      ; finally, close only this file
000011E0  103C 0038               3069      MOVE.B #56, D0 ; close file task
000011E4  4E4F                    3070      trap #15
000011E6                          3071    
000011E6                          3072      ; report to screen
000011E6  224A                    3073      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
000011E8  103C 000D               3074      MOVE.B #13, D0
000011EC  4E4F                    3075      trap #15
000011EE                          3076        
000011EE                          3077      ; restore context
000011EE  4CDF 0C3F               3078      MOVEM.L (SP)+, toSave
000011F2                          3079      
000011F2  4E75                    3080      RTS
000011F4                          3081  
000011F4                          3082    
000011F4                          3083  *----------------------------------------------------------------------------------
000011F4                          3084  * Method Name: AsciiToHex
000011F4                          3085  * Written by : Berger, Modified by Nash
000011F4                          3086  * Date       : 3/1/2019
000011F4                          3087  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
000011F4                          3088  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into 
000011F4                          3089  *              its (4b each) equivalent hex value 
000011F4                          3090  *  
000011F4                          3091  *  Preconditions & Input
000011F4                          3092  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated) 
000011F4                          3093  *       This function calls another function (strip_ascii)
000011F4                          3094  *
000011F4                          3095  *  Postconditions & Output
000011F4                          3096  *       D7 (output) holds the converted value 
000011F4                          3097  *       Caller-Saved : D0 is temp, D6 is a loop var
000011F4                          3098  *----------------------------------------------------------------------------------
000011F4                          3099  AsciiToHexRegList REG D0,D6
000011F4                          3100  AsciiToHex     
000011F4  48E7 0200               3101      MOVEM.L d6, -(SP)  *save context
000011F8  4287                    3102      CLR.L D7 * clear our return value
000011FA  7C08                    3103      MOVE.L #8, D6 ; and set up our loop counter
000011FC                          3104  
000011FC                          3105  chrLoop
000011FC  1019                    3106      MOVE.B (A1)+,D0 * Get the first byte
000011FE  4EB9 00001216           3107      jsr strip_ascii * Get rid of the ascii code    
00001204  8E40                    3108      OR.W D0,D7 * Load the bits into D7
00001206                          3109      
00001206  5306                    3110      subI.B #1,D6  *decrement our loop variable
00001208  6700 0006               3111      BEQ chrDone   *skip shifting if we are done
0000120C                          3112      
0000120C  E987                    3113      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
0000120E  60EC                    3114      BRA chrLoop
00001210                          3115  
00001210                          3116  chrDone
00001210  4CDF 0040               3117      MOVEM.L (SP)+,d6 
00001214  4E75                    3118      RTS
00001216                          3119  
00001216                          3120  **********************************************************************
00001216                          3121  * SUBROUTINE: strip_ascii
00001216                          3122  * remove the ascii code from the digits 0-9,a-f, or A-F
00001216                          3123  * Input Parameters: <D0> = ascii code
00001216                          3124  *
00001216                          3125  * Return parameters: D0.B = number 0...F, returned as 00...0F
00001216                          3126  * Registers used internally: D0
00001216                          3127  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
00001216                          3128  *
00001216                          3129  ***********************************************************************
00001216                          3130  strip_ascii
00001216  B03C 0039               3131        CMP.B #$39,D0 * Is it in range of 0-9?
0000121A  6F00 001A               3132        BLE sub30 * Its a number
0000121E  B03C 0046               3133        CMP.B #$46,D0 * Is is A...F?
00001222  6F00 000A               3134        BLE sub37 * Its A...F
00001226  0400 0057               3135        SUB.B #$57,D0 * Its a...f
0000122A  6000 000E               3136        BRA ret_sa * Go back
0000122E  0400 0037               3137  sub37 SUB.B #$37,D0 * Strip 37
00001232  6000 0006               3138        BRA ret_sa * Go back
00001236  0400 0030               3139  sub30 SUB.B #$30,D0 * Strip 30
0000123A  4E75                    3140  ret_sa RTS * Go back
0000123C                          3141  
0000123C                          3142  
0000123C                          3143  
0000123C                          3144  
0000123C                          3145  ***********************************************************************    
0000123C                          3146  * Required variables and constants go here for your Disassembler
0000123C                          3147  ***********************************************************************
0000123C                          3148  
0000123C  =0000000D               3149  CR                  EQU $0D
0000123C  =0000000A               3150  LF                  EQU $0A
0000123C                          3151    
0000123C= 4D 4F 56 45 2E 4C ...   3152  MSG1                DC.B 'MOVE.L D4,D5',0
00001249= 41 44 44 2E 42 20 ...   3153  MSG2                DC.B 'ADD.B D0,D1',0
00001255                          3154  
00001255= 4F 75 74 70 75 74 ...   3155  outFilename         DC.B 'Output.txt',0
00001260= 43 6F 6E 66 69 67 ...   3156  configFile          DC.B 'Config.cfg',0
0000126B                          3157  
0000126B                          3158  fileBuffer          DS.B 20             ;a buffer for the Config.cfg file
0000127F                          3159  byteRead            DS.B 1
00001280= 31 41 30 30 31 41 ...   3160  ascii_val           DC.B $31,$41,$30,$30,$31,$41,$30,$30 * Test value $1A001A00
00001288                          3161  
00001288                          3162  * Storage buffers,poainters, and flags
00001288                          3163  storeAddr       DS.L    1       ;temp address storage
0000128C                          3164  immSize         DS.B    1       ;size of immediate value, set by Opcode person so EA person knows how big (B, W, or L)
0000128D                          3165  flag            DS.B    1       ;good/bad flag, 1 means readable, 0 means can't decode
0000128E                          3166  printBuffer     DS.W    40      ;storage buffer for printing data/addresses/opcodes, null terminated
000012DE                          3167  hex2ascBuffer   DS.L    2       ;temp buffer for storing hex to ascii conversions before loading into printBuffer, null terminated
000012E6                          3168  
000012E6                          3169  * Misc characters
000012E6= 0D 0A 00                3170  NEWLINE         DC.B CR,LF,0
000012E9= 2C 20 00                3171  comma           DC.B    ', ',0      ;print a comma and space
000012EC= 23 00                   3172  hashtag         DC.B    '#',0       ;print # sign for immediate data
000012EE= 24 00                   3173  hexSign         DC.B    '$',0       ;print $ for hex values
000012F0= 2F 00                   3174  forwardSlash    DC.B    '/',0       ;print $ for movem register lists
000012F2= 20 00                   3175  space           DC.B    ' ',0
000012F4                          3176  * Opcodes for printing
000012F4= 20 20 44 41 54 41 ...   3177  dataMSG         DC.B    '  DATA  ',0
000012FD= 20 20 4F 52 49 00       3178  oriMSG          DC.B    '  ORI',0
00001303= 20 20 41 44 44 49 00    3179  addiMSG         DC.B    '  ADDI',0
0000130A= 20 20 43 4D 50 49 00    3180  cmpiMSG         DC.B    '  CMPI',0
00001311= 20 20 42 43 4C 52 ...   3181  bclrMSG         DC.B    '  BCLR ',0
00001319= 20 20 4D 4F 56 45 ...   3182  moveaMSG        DC.B    '  MOVEA',0
00001321= 20 20 4D 4F 56 45 00    3183  moveMSG         DC.B    '  MOVE',0
00001328= 20 20 43 4C 52 00       3184  clrMSG          DC.B    '  CLR',0
0000132E= 20 20 4E 45 47 00       3185  negMSG          DC.B    '  NEG',0
00001334= 20 20 52 54 53 00       3186  rtsMSG          DC.B    '  RTS',0
0000133A= 20 20 4A 53 52 20 00    3187  jsrMSG          DC.B    '  JSR ',0
00001341= 20 20 4D 4F 56 45 ...   3188  movemMSG        DC.B    '  MOVEM',0
00001349= 20 20 4C 45 41 20 00    3189  leaMSG          DC.B    '  LEA ',0
00001350= 20 20 43 48 4B 00       3190  chkMSG          DC.B    '  CHK',0
00001356= 20 20 41 44 44 51 00    3191  addqMSG         DC.B    '  ADDQ',0
0000135D= 20 20 53 55 42 51 00    3192  subqMSG         DC.B    '  SUBQ',0
00001364= 20 20 42 52 41 20 00    3193  braMSG          DC.B    '  BRA ',0
0000136B= 20 20 42 43 43 20 00    3194  bccMSG          DC.B    '  BCC ',0
00001372= 20 20 42 43 53 20 00    3195  bcsMSG          DC.B    '  BCS ',0
00001379= 20 20 42 45 51 20 00    3196  beqMSG          DC.B    '  BEQ ',0
00001380= 20 20 42 47 45 20 00    3197  bgeMSG          DC.B    '  BGE ',0
00001387= 20 20 42 47 54 20 00    3198  bgtMSG          DC.B    '  BGT ',0
0000138E= 20 20 42 48 49 20 00    3199  bhiMSG          DC.B    '  BHI ',0
00001395= 20 20 42 4C 45 20 00    3200  bleMSG          DC.B    '  BLE ',0
0000139C= 20 20 42 4C 53 20 00    3201  blsMSG          DC.B    '  BLS ',0
000013A3= 20 20 42 4C 54 20 00    3202  bltMSG          DC.B    '  BLT ',0
000013AA= 20 20 42 4D 49 20 00    3203  bmiMSG          DC.B    '  BMI ',0
000013B1= 20 20 42 4E 45 20 00    3204  bneMSG          DC.B    '  BNE ',0
000013B8= 20 20 42 50 4C 20 00    3205  bplMSG          DC.B    '  BPL ',0
000013BF= 20 20 42 56 43 20 00    3206  bvcMSG          DC.B    '  BVC ',0
000013C6= 20 20 42 56 53 20 00    3207  bvsMSG          DC.B    '  BVS ',0
000013CD= 20 20 44 49 56 53 00    3208  divsMSG         DC.B    '  DIVS',0
000013D4= 20 20 4F 52 00          3209  orMSG           DC.B    '  OR',0
000013D9= 20 20 53 55 42 00       3210  subMSG          DC.B    '  SUB',0
000013DF= 20 20 45 4F 52 00       3211  eorMSG          DC.B    '  EOR',0
000013E5= 20 20 43 4D 50 00       3212  cmpMSG          DC.B    '  CMP',0
000013EB= 20 20 4D 55 4C 53 00    3213  mulsMSG         DC.B    '  MULS',0
000013F2= 20 20 41 44 44 00       3214  addMSG          DC.B    '  ADD',0
000013F8= 20 20 41 44 44 41 00    3215  addaMSG         DC.B    '  ADDA',0
000013FF= 20 20 41 53 4C 00       3216  aslMSG          DC.B    '  ASL',0
00001405= 20 20 41 53 52 00       3217  asrMSG          DC.B    '  ASR',0
0000140B= 20 20 4C 53 4C 00       3218  lslMSG          DC.B    '  LSL',0
00001411= 20 20 4C 53 52 00       3219  lsrMSG          DC.B    '  LSR',0
00001417= 20 20 52 4F 4C 00       3220  rolMSG          DC.B    '  ROL',0
0000141D= 20 20 52 4F 52 00       3221  rorMSG          DC.B    '  ROR',0
00001423                          3222  
00001423                          3223  * Size operations for printing
00001423= 2E 42 20 00             3224  byteMSG         DC.B    '.B ',0
00001427= 2E 57 20 00             3225  wordMSG         DC.B    '.W ',0
0000142B= 2E 4C 20 00             3226  longMSG         DC.B    '.L ',0
0000142F                          3227  
0000142F                          3228  * EA Modes for printing
0000142F= 44 30 00                3229  d0MSG           DC.B    'D0',0
00001432= 44 31 00                3230  d1MSG           DC.B    'D1',0
00001435= 44 32 00                3231  d2MSG           DC.B    'D2',0
00001438= 44 33 00                3232  d3MSG           DC.B    'D3',0
0000143B= 44 34 00                3233  d4MSG           DC.B    'D4',0
0000143E= 44 35 00                3234  d5MSG           DC.B    'D5',0
00001441= 44 36 00                3235  d6MSG           DC.B    'D6',0
00001444= 44 37 00                3236  d7MSG           DC.B    'D7',0
00001447                          3237  
00001447= 41 30 00                3238  ar0MSG          DC.B    'A0',0          
0000144A= 41 31 00                3239  ar1MSG          DC.B    'A1',0          
0000144D= 41 32 00                3240  ar2MSG          DC.B    'A2',0
00001450= 41 33 00                3241  ar3MSG          DC.B    'A3',0
00001453= 41 34 00                3242  ar4MSG          DC.B    'A4',0
00001456= 41 35 00                3243  ar5MSG          DC.B    'A5',0
00001459= 41 36 00                3244  ar6MSG          DC.B    'A6',0
0000145C= 41 37 00                3245  ar7MSG          DC.B    'A7',0        
0000145F                          3246  
0000145F= 28 41 30 29 00          3247  ari0MSG         DC.B    '(A0)',0
00001464= 28 41 31 29 00          3248  ari1MSG         DC.B    '(A1)',0
00001469= 28 41 32 29 00          3249  ari2MSG         DC.B    '(A2)',0
0000146E= 28 41 33 29 00          3250  ari3MSG         DC.B    '(A3)',0
00001473= 28 41 34 29 00          3251  ari4MSG         DC.B    '(A4)',0
00001478= 28 41 35 29 00          3252  ari5MSG         DC.B    '(A5)',0
0000147D= 28 41 36 29 00          3253  ari6MSG         DC.B    '(A6)',0
00001482= 28 41 37 29 00          3254  ari7MSG         DC.B    '(A7)',0
00001487                          3255  
00001487= 28 41 30 29 2B 00       3256  arpi0MSG        DC.B    '(A0)+',0
0000148D= 28 41 31 29 2B 00       3257  arpi1MSG        DC.B    '(A1)+',0
00001493= 28 41 32 29 2B 00       3258  arpi2MSG        DC.B    '(A2)+',0
00001499= 28 41 33 29 2B 00       3259  arpi3MSG        DC.B    '(A3)+',0
0000149F= 28 41 34 29 2B 00       3260  arpi4MSG        DC.B    '(A4)+',0
000014A5= 28 41 35 29 2B 00       3261  arpi5MSG        DC.B    '(A5)+',0
000014AB= 28 41 36 29 2B 00       3262  arpi6MSG        DC.B    '(A6)+',0
000014B1= 28 41 37 29 2B 00       3263  arpi7MSG        DC.B    '(A7)+',0
000014B7                          3264            
000014B7= 2D 28 41 30 29 00       3265  arpd0MSG        DC.B    '-(A0)',0
000014BD= 2D 28 41 31 29 00       3266  arpd1MSG        DC.B    '-(A1)',0
000014C3= 2D 28 41 32 29 00       3267  arpd2MSG        DC.B    '-(A2)',0
000014C9= 2D 28 41 33 29 00       3268  arpd3MSG        DC.B    '-(A3)',0
000014CF= 2D 28 41 34 29 00       3269  arpd4MSG        DC.B    '-(A4)',0
000014D5= 2D 28 41 35 29 00       3270  arpd5MSG        DC.B    '-(A5)',0
000014DB= 2D 28 41 36 29 00       3271  arpd6MSG        DC.B    '-(A6)',0
000014E1= 2D 28 41 37 29 00       3272  arpd7MSG        DC.B    '-(A7)',0          
000014E7                          3273  
000014E7                          3274  
000014E7                          3275  
000014E7                          3276  
000014E7                          3277  
000014E7                          3278  
000014E7                          3279  
000014E7                          3280     END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             33DC
ABSOLUTE            2FAC
ABSSHORT            33B2
ADD2BUFFER          1102
ADD30               1158
ADD37               1150
ADDAMSG             13F8
ADDIMSG             1303
ADDMSG              13F2
ADDQMSG             1356
ADDQ_HEX_CONV       2208
ADDRESS             3160
ADDRPOST            3226
ADDRPRE             32EC
ADDRREG             309A
ADD_ASCII           113C
ADD_L               26A0
ADRPI0              3306
ADRPI1              331C
ADRPI2              3332
ADRPI3              3348
ADRPI4              335E
ADRPI5              3374
ADRPI6              338A
ADRPI7              33A0
AR0                 30B4
AR0MSG              1447
AR1                 30CA
AR1MSG              144A
AR2                 30E0
AR2MSG              144D
AR3                 30F6
AR3MSG              1450
AR4                 310C
AR4MSG              1453
AR5                 3122
AR5MSG              1456
AR6                 3138
AR6MSG              1459
AR7                 314E
AR7MSG              145C
ARI0                317A
ARI0MSG             145F
ARI1                3190
ARI1MSG             1464
ARI2                31A6
ARI2MSG             1469
ARI3                31BC
ARI3MSG             146E
ARI4                31D2
ARI4MSG             1473
ARI5                31E8
ARI5MSG             1478
ARI6                31FE
ARI6MSG             147D
ARI7                3214
ARI7MSG             1482
ARPD0MSG            14B7
ARPD1MSG            14BD
ARPD2MSG            14C3
ARPD3MSG            14C9
ARPD4MSG            14CF
ARPD5MSG            14D5
ARPD6MSG            14DB
ARPD7MSG            14E1
ARPI0               3240
ARPI0MSG            1487
ARPI1               3256
ARPI1MSG            148D
ARPI2               326C
ARPI2MSG            1493
ARPI3               3282
ARPI3MSG            1499
ARPI4               3298
ARPI4MSG            149F
ARPI5               32AE
ARPI5MSG            14A5
ARPI6               32C4
ARPI6MSG            14AB
ARPI7               32DA
ARPI7MSG            14B1
ASCIITOHEX          11F4
ASCIITOHEXREGLIST   1
ASCII_VAL           1280
ASLMSG              13FF
ASL_HEX_CONV        27A8
ASL_IM              2778
ASRMSG              1405
ASR_HEX_CONV        2844
ASR_IM              2814
A_FIVE              2D9E
A_FOUR              2D88
A_ONE               2D46
A_SEVEN             2DCA
A_SIX               2DB4
A_THREE             2D72
A_TWO               2D5C
BADFLAG             2BB6
BCCMSG              136B
BCC_DECODE          2232
BCLRMSG             1311
BCSMSG              1372
BEQMSG              1379
BGEMSG              1380
BGTMSG              1387
BHIMSG              138E
BITM_A              3174
BITM_AP             323A
BITM_APRE           3300
BITM_AR             30AE
BITM_D              2FE8
BLEMSG              1395
BLSMSG              139C
BLTMSG              13A3
BMIMSG              13AA
BNEMSG              13B1
BPLMSG              13B8
BRAMSG              1364
BVCMSG              13BF
BVSMSG              13C6
BYTEMSG             1423
BYTEREAD            127F
BYTE_DSP            23F6
B_SKIP              238E
CANNOTDECODE        2FD0
CANTDECODE          1096
CHKMSG              1350
CHRDONE             1210
CHRLOOP             11FC
CLRMSG              1328
CMPIMSG             130A
CMPMSG              13E5
COMMA               12E9
CONFIGFILE          1260
CONVDONE            1136
CONVLOOP            111A
COUNTDONE           11B0
COUNTLOOP           119E
CR                  D
D0MSG               142F
D1MSG               1432
D2E                 263A
D2MSG               1435
D3MSG               1438
D4MSG               143B
D5MSG               143E
D6MSG               1441
D7MSG               1444
DATA0               2FEE
DATA1               3004
DATA2               301A
DATA3               3030
DATA4               3046
DATA5               305C
DATA6               3072
DATA7               3088
DATAMSG             12F4
DATAREG             2FD4
DECADD              25F8
DECADDA             2654
DECADDI             1768
DECADDQ             21C8
DECASL              26CA
DECASLREG           2720
DECASR              2700
DECASRREG           27D2
DECBCC              227A
DECBCLRDR           179C
DECBCLRIM           17D8
DECBCS              2292
DECBEQ              22C2
DECBGE              233A
DECBGT              236A
DECBHI              224A
DECBLE              2382
DECBLS              2262
DECBLT              2352
DECBMI              2322
DECBNE              22AA
DECBPL              230A
DECBRA              2232
DECBVC              22DA
DECBVS              22F2
DECCHK              20EC
DECCLR              1984
DECCMP              2580
DECCMPI             1782
DECDIVS             2412
DECEOR              2554
DECJSR              19C6
DECLEA              20BA
DECLSL              286E
DECLSLREG           28C4
DECLSR              28A4
DECLSRREG           2976
DECMOVE             18CE
DECMOVEA            184A
DECMOVEMM2R         1A82
DECMOVEMR2M         19FC
DECMULS             25AC
DECNEG              199E
DECODE_AN           2D22
DECODE_DN           2BBC
DECOR               245A
DECORI              174E
DECROL              2A12
DECROLREG           2A68
DECROR              2A48
DECRORREG           2B1A
DECRTS              19B8
DECSUB              24F8
DECSUBQ             215C
DISASSEMBLER        1000
DISLOOP             104C
DIVSMSG             13CD
D_FIVE              2C38
D_FOUR              2C22
D_ONE               2BE0
D_SEVEN             2C64
D_SIX               2C4E
D_THREE             2C0C
D_TWO               2BF6
D_ZERO              2BCA
EA                  2F4E
ED2E                253A
ENDCHK              2142
ENDPROG             10FE
EORMSG              13DF
FILEBUFFER          126B
FINDNULLLOOPDONE    1180
FLAG                128D
FORWARDSLASH        12F0
GET_IM_SIZE         2E38
GET_SIZE            2DD8
HASHTAG             12EC
HEX2ASCBUFFER       12DE
HEXSIGN             12EE
HEXTOASCII          110C
IMMED               3406
IMMSIZE             128C
JSRMSG              133A
LEAMSG              1349
LF                  A
LOAD_L              2132
LOAD_W              211C
LONGMSG             142B
LONG_DSP            23CE
LSLMSG              140B
LSL_HEX_CONV        294C
LSL_IM              291C
LSRMSG              1411
LSR_HEX_CONV        29E8
LSR_IM              29B8
M2R_LONG            1AD0
M2R_WORD            1A9C
MA_SKIP1            1896
MA_SKIP2            18C8
MODE                2F76
MOVEAMSG            1319
MOVEMMSG            1341
MOVEMSG             1321
MOVEM_DECODE_REGS   1B04
MOVEM_POSTA0        1F54
MOVEM_POSTA1        1F82
MOVEM_POSTA2        1FB0
MOVEM_POSTA3        1FDE
MOVEM_POSTA4        200C
MOVEM_POSTA5        203A
MOVEM_POSTA6        2068
MOVEM_POSTA7        2096
MOVEM_POSTD0        1DEA
MOVEM_POSTD1        1E12
MOVEM_POSTD2        1E40
MOVEM_POSTD3        1E6E
MOVEM_POSTD4        1E9C
MOVEM_POSTD5        1ECA
MOVEM_POSTD6        1EF8
MOVEM_POSTD7        1F26
MOVEM_POSTEND       20B8
MOVEM_PREA0         1C8A
MOVEM_PREA1         1CB8
MOVEM_PREA2         1CE6
MOVEM_PREA3         1D14
MOVEM_PREA4         1D42
MOVEM_PREA5         1D70
MOVEM_PREA6         1D9E
MOVEM_PREA7         1DCC
MOVEM_PRED0         1B1A
MOVEM_PRED1         1B48
MOVEM_PRED2         1B76
MOVEM_PRED3         1BA4
MOVEM_PRED4         1BD2
MOVEM_PRED5         1C00
MOVEM_PRED6         1C2E
MOVEM_PRED7         1C5C
MOVEM_PREEND        1DE8
MOVE_EA             2F62
MSG1                123C
MSG2                1249
MULSMSG             13EB
M_SKIP1             191A
M_SKIP2             194C
M_SKIP3             197E
NEGMSG              132E
NEWLINE             12E6
NULLLOOP            1172
OP0                 1578
OP1                 15C2
OP4                 15DE
OP4_1               1632
OP5                 1656
OP6                 1670
OP8                 168C
OPB                 16A8
OPCODE              1504
OPD                 16C4
OPE                 16E0
OPE_SKIP            1722
ORIMSG              12FD
ORMSG               13D4
OUTFILENAME         1255
O_DIRECTION         24AE
O_MEM2REG           24BC
O_REG2MEM           24DE
O_SKIP1             2482
O_SKIP2             249E
PRINTBUFFER         128E
R2M_LONG            1A4C
R2M_WORD            1A16
RET_A2H             115C
RET_SA              123A
ROLMSG              1417
ROL_HEX_CONV        2AF0
ROL_IM              2AC0
RORMSG              141D
ROR_HEX_CONV        2B8C
ROR_IM              2B5C
RTSMSG              1334
SBYTE               2E02
SIZE_B              2E4E
SIZE_BYTE           3426
SIZE_L              2EF6
SIZE_LONG           346E
SIZE_W              2E9E
SIZE_WORD           3446
SLONG               2E26
SPACE               12F2
START               1500
STOREADDR           1288
STRIP_ASCII         1216
SUB30               1236
SUB37               122E
SUBMSG              13D9
SUBQMSG             135D
SUBQ_HEX_CONV       219E
SWORD               2E14
TOSAVE              C3F
TRAPTASK13          115E
V2DECODE_DN         2C72
V2D_FIVE            2CE8
V2D_FOUR            2CD2
V2D_ONE             2C90
V2D_SEVEN           2D14
V2D_SIX             2CFE
V2D_THREE           2CBC
V2D_TWO             2CA6
V2D_ZERO            2C7A
WORDMSG             1427
WORD_DSP            23A6
_00000000           1194
